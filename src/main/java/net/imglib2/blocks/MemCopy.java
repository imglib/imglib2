/*-
 * #%L
 * ImgLib2: a general-purpose, multidimensional image processing library.
 * %%
 * Copyright (C) 2009 - 2025 Tobias Pietzsch, Stephan Preibisch, Stephan Saalfeld,
 * John Bogovic, Albert Cardona, Barry DeZonia, Christian Dietz, Jan Funke,
 * Aivar Grislis, Jonathan Hale, Grant Harris, Stefan Helfrich, Mark Hiner,
 * Martin Horn, Steffen Jaensch, Lee Kamentsky, Larry Lindsey, Melissa Linkert,
 * Mark Longair, Brian Northan, Nick Perry, Curtis Rueden, Johannes Schindelin,
 * Jean-Yves Tinevez and Michael Zinsmaier.
 * %%
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 * 1. Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 * #L%
 */
package net.imglib2.blocks;

import java.nio.Buffer;
import java.nio.ByteBuffer;
import java.nio.CharBuffer;
import java.nio.DoubleBuffer;
import java.nio.FloatBuffer;
import java.nio.IntBuffer;
import java.nio.LongBuffer;
import java.nio.ShortBuffer;
import java.util.Arrays;

import net.imglib2.type.PrimitiveType;

/*
 * This is autogenerated source code -- DO NOT EDIT. Instead, edit the
 * corresponding template in templates/ and rerun bin/generate.groovy.
 */

// TODO javadoc
// low-level copying methods
// implementations for all primitive types
// T is a primitive array type

/**
 * Low-level range copying methods between source {@code S} and target {@code T}
 * which can be either primitive array types (e.g., {@code double[]}) or the
 * corresponding {@code Buffer} (e.g., {@code DoubleBuffer}).
 * <p>
 * All combinations are implemented (e.g., {@code byte[]}-to-{@code byte[]},
 * {@code byte[]}-to-{@code ByteBuffer}, {@code ByteBuffer}-to-{@code byte[]},
 * and {@code ByteBuffer}-to-{@code ByteBuffer}).
 *
 * @param <S>
 * 		the source type. Must be a primitive array or buffer type (e.g., {@code double[]} or {@code IntBuffer})
 * @param <T>
 * 		the target type. Must be a primitive array or buffer type (e.g., {@code double[]} or {@code IntBuffer})
 */
interface MemCopy< S, T >
{
	/**
	 * Copy {@code length} components from the {@code src} array to the {@code
	 * dest} array. The components at positions {@code srcPos} through {@code
	 * srcPos+length-1} in the source array are copied into positions {@code
	 * destPos} through {@code destPos+length-1}, respectively, of the
	 * destination array.
	 */
	void copyForward( S src, int srcPos, T dest, int destPos, int length );

	/**
	 * Copy {@code length} components from the {@code src} array to the {@code
	 * dest} array, in reverse order. The components at positions {@code srcPos}
	 * through {@code srcPos-length-1} in the source array are copied into
	 * positions {@code destPos} through {@code destPos+length-1}, respectively,
	 * of the destination array.
	 */
	void copyReverse( S src, int srcPos, T dest, int destPos, int length );

	/**
	 * Copy component at position {@code srcPos} in the {@code src} array
	 * ({@code length} times) into positions {@code destPos} through {@code
	 * destPos+length-1} of the destination array.
	 */
	void copyValue( S src, int srcPos, T dest, int destPos, int length );

	/**
	 * Copy {@code length} components from the {@code src} array to the {@code
	 * dest} array. The components at positions {@code srcPos} through {@code
	 * srcPos+length-1} in the source array are copied into positions {@code
	 * destPos}, {@code destPos+destStride}, {@code destPos + 2*destStride},
	 * etc., through {@code destPos+(length-1)*destStride} of the destination
	 * array.
	 */
	void copyStrided( S src, int srcPos, T dest, int destPos, int destStride, int length );

	/**
	 * Copy {@code numLines} stretches of {@code lineLength} elements.
	 *
	 * @param lineDir {@code 1}, {@code -1}, or {@code 0}. This corresponds (for every line being copied) to the source position moving forward, backward, or not at all, as the dest position is moving forward.
	 * @param lineLength how many elements to copy per line
	 * @param numLines how many lines to copy
	 * @param src source array
	 * @param srcPos starting position in source array
	 * @param srcStep offset to next line in src
	 * @param dest dest array
	 * @param destPos starting position in dest array
	 * @param destStep offset to next line in dest
	 */
	// Note that this default implementation is overridden in each
	// implementation (with identical code) to soften the performance hit from
	// polymorphism. The default implementation is left here, to make additional
	// implementations easier.
	default void copyLines(
			final int lineDir,
			final int lineLength,
			final int numLines,
			final S src,
			final int srcPos,
			final int srcStep,
			final T dest,
			final int destPos,
			final int destStep )
	{
		if ( lineDir == 1 )
			for ( int i = 0; i < numLines; ++i )
				copyForward( src, srcPos + i * srcStep, dest, destPos + i * destStep, lineLength );
		else if ( lineDir == -1 )
			for ( int i = 0; i < numLines; ++i )
				copyReverse( src, srcPos + i * srcStep, dest, destPos + i * destStep, lineLength );
		else // cstep0 == 0
			for ( int i = 0; i < numLines; ++i )
				copyValue( src, srcPos + i * srcStep, dest, destPos + i * destStep, lineLength );
	}

	/**
	 * Recursively copy a {@code (d+1)} dimensional region from {@code src} to
	 * {@code dest}, where {@code src} and {@code dest} are flattened nD array
	 * with strides {@code srcStrides} and {@code destStrides}, respectively.
	 * <p>
	 * For {@code d=0}, a 1D line of length {@code size[0]} is copied
	 * (equivalent to {@code System.arraycopy}). For {@code d=1}, a 2D plane of
	 * size {@code size[0] * size[1]} is copied, by recursively copying 1D
	 * lines, starting {@code srcStrides[1]} (respectively {@code
	 * destStrides[1]}) apart. For {@code d=2}, a 3D box is copied by
	 * recursively copying 2D planes, etc.
	 *
	 * @param d
	 * 		current dimension
	 * @param src
	 * 		flattened nD source array
	 * @param srcStrides
	 *      nD strides of src
	 * @param srcPos
	 * 		flattened index (in src) to start copying from
	 * @param dest
	 * 		flattened nD destination array
	 * @param destStrides
	 *      nD strides of dest
	 * @param destPos
	 * 		flattened index (in dest) to start copying to
	 * @param size
	 * 		nD size of the range to copy
	 */
	// Note that this default implementation is overridden in each
	// implementation (with identical code) to soften the performance hit from
	// polymorphism. The default implementation is left here, to make additional
	// implementations easier.
	default void copyNDRangeRecursive(
			final int d,
			final S src,
			final int[] srcStrides,
			final int srcPos,
			final T dest,
			final int[] destStrides,
			final int destPos,
			final int[] size )
	{
		final int len = size[ d ];
		if ( d > 0 )
		{
			final int stride_src = srcStrides[ d ];
			final int stride_dst = destStrides[ d ];
			for ( int i = 0; i < len; ++i )
				copyNDRangeRecursive( d - 1,
						src, srcStrides, srcPos + i * stride_src,
						dest, destStrides, destPos + i * stride_dst,
						size );
		}
		else
			copyForward( src, srcPos, dest, destPos, len );
	}

	MemCopyBoolean BOOLEAN = new MemCopyBoolean();
	MemCopyByte BYTE = new MemCopyByte();
	MemCopyChar CHAR = new MemCopyChar();
	MemCopyShort SHORT = new MemCopyShort();
	MemCopyInt INT = new MemCopyInt();
	MemCopyLong LONG = new MemCopyLong();
	MemCopyFloat FLOAT = new MemCopyFloat();
	MemCopyDouble DOUBLE = new MemCopyDouble();

	MemCopyByteBufferToArray BUFFER_TO_ARRAY_BYTE = new MemCopyByteBufferToArray();
	MemCopyCharBufferToArray BUFFER_TO_ARRAY_CHAR = new MemCopyCharBufferToArray();
	MemCopyShortBufferToArray BUFFER_TO_ARRAY_SHORT = new MemCopyShortBufferToArray();
	MemCopyIntBufferToArray BUFFER_TO_ARRAY_INT = new MemCopyIntBufferToArray();
	MemCopyLongBufferToArray BUFFER_TO_ARRAY_LONG = new MemCopyLongBufferToArray();
	MemCopyFloatBufferToArray BUFFER_TO_ARRAY_FLOAT = new MemCopyFloatBufferToArray();
	MemCopyDoubleBufferToArray BUFFER_TO_ARRAY_DOUBLE = new MemCopyDoubleBufferToArray();

	MemCopyByteArrayToBuffer ARRAY_TO_BUFFER_BYTE = new MemCopyByteArrayToBuffer();
	MemCopyCharArrayToBuffer ARRAY_TO_BUFFER_CHAR = new MemCopyCharArrayToBuffer();
	MemCopyShortArrayToBuffer ARRAY_TO_BUFFER_SHORT = new MemCopyShortArrayToBuffer();
	MemCopyIntArrayToBuffer ARRAY_TO_BUFFER_INT = new MemCopyIntArrayToBuffer();
	MemCopyLongArrayToBuffer ARRAY_TO_BUFFER_LONG = new MemCopyLongArrayToBuffer();
	MemCopyFloatArrayToBuffer ARRAY_TO_BUFFER_FLOAT = new MemCopyFloatArrayToBuffer();
	MemCopyDoubleArrayToBuffer ARRAY_TO_BUFFER_DOUBLE = new MemCopyDoubleArrayToBuffer();

	MemCopyByteBufferToBuffer BUFFER_TO_BUFFER_BYTE = new MemCopyByteBufferToBuffer();
	MemCopyCharBufferToBuffer BUFFER_TO_BUFFER_CHAR = new MemCopyCharBufferToBuffer();
	MemCopyShortBufferToBuffer BUFFER_TO_BUFFER_SHORT = new MemCopyShortBufferToBuffer();
	MemCopyIntBufferToBuffer BUFFER_TO_BUFFER_INT = new MemCopyIntBufferToBuffer();
	MemCopyLongBufferToBuffer BUFFER_TO_BUFFER_LONG = new MemCopyLongBufferToBuffer();
	MemCopyFloatBufferToBuffer BUFFER_TO_BUFFER_FLOAT = new MemCopyFloatBufferToBuffer();
	MemCopyDoubleBufferToBuffer BUFFER_TO_BUFFER_DOUBLE = new MemCopyDoubleBufferToBuffer();

	static MemCopy< ?, ? > forPrimitiveType( final PrimitiveType primitiveType )
	{
		return forPrimitiveType( primitiveType, false, false );
	}

	static MemCopy< ?, ? > forPrimitiveType( final PrimitiveType primitiveType, final boolean fromBuffer, final boolean toBuffer )
	{
		switch ( primitiveType )
		{
		case BOOLEAN:
			if ( fromBuffer || toBuffer )
				throw new IllegalArgumentException( "No BufferAccess implementation for PrimitiveType.BOOLEAN" );
			else
				return BOOLEAN;
		case BYTE:
			return fromBuffer
					? ( toBuffer ? BUFFER_TO_BUFFER_BYTE : BUFFER_TO_ARRAY_BYTE )
					: ( toBuffer ? ARRAY_TO_BUFFER_BYTE : BYTE );
		case CHAR:
			return fromBuffer
					? ( toBuffer ? BUFFER_TO_BUFFER_CHAR : BUFFER_TO_ARRAY_CHAR )
					: ( toBuffer ? ARRAY_TO_BUFFER_CHAR : CHAR );
		case SHORT:
			return fromBuffer
					? ( toBuffer ? BUFFER_TO_BUFFER_SHORT : BUFFER_TO_ARRAY_SHORT )
					: ( toBuffer ? ARRAY_TO_BUFFER_SHORT : SHORT );
		case INT:
			return fromBuffer
					? ( toBuffer ? BUFFER_TO_BUFFER_INT : BUFFER_TO_ARRAY_INT )
					: ( toBuffer ? ARRAY_TO_BUFFER_INT : INT );
		case LONG:
			return fromBuffer
					? ( toBuffer ? BUFFER_TO_BUFFER_LONG : BUFFER_TO_ARRAY_LONG )
					: ( toBuffer ? ARRAY_TO_BUFFER_LONG : LONG );
		case FLOAT:
			return fromBuffer
					? ( toBuffer ? BUFFER_TO_BUFFER_FLOAT : BUFFER_TO_ARRAY_FLOAT )
					: ( toBuffer ? ARRAY_TO_BUFFER_FLOAT : FLOAT );
		case DOUBLE:
			return fromBuffer
					? ( toBuffer ? BUFFER_TO_BUFFER_DOUBLE : BUFFER_TO_ARRAY_DOUBLE )
					: ( toBuffer ? ARRAY_TO_BUFFER_DOUBLE : DOUBLE );
		default:
		case UNDEFINED:
			throw new IllegalArgumentException();
		}
	}


	// TODO: Remove?
	static PrimitiveType primitiveTypeForClass( final Class< ? > clz )
	{
		if ( clz.equals( boolean[].class ) )
			return PrimitiveType.BOOLEAN;
		else if ( clz.equals( byte[].class ) || clz.equals( ByteBuffer.class ) )
			return PrimitiveType.BYTE;
		else if ( clz.equals( char[].class ) || clz.equals( CharBuffer.class ) )
			return PrimitiveType.CHAR;
		else if ( clz.equals( short[].class ) || clz.equals( ShortBuffer.class ) )
			return PrimitiveType.SHORT;
		else if ( clz.equals( int[].class ) || clz.equals( IntBuffer.class ) )
			return PrimitiveType.INT;
		else if ( clz.equals( long[].class ) || clz.equals( LongBuffer.class ) )
			return PrimitiveType.LONG;
		else if ( clz.equals( float[].class ) || clz.equals( FloatBuffer.class ) )
			return PrimitiveType.FLOAT;
		else if ( clz.equals( double[].class ) || clz.equals( DoubleBuffer.class ) )
			return PrimitiveType.DOUBLE;
		else
			throw new IllegalArgumentException();
	}

	// TODO: Remove?
	static MemCopy< ?, ? > forClasses( final Class< ? > srcClass, final Class< ? > destClass )
	{
		final PrimitiveType primitiveType = primitiveTypeForClass( srcClass );
		if ( !primitiveTypeForClass( destClass ).equals( primitiveType ) )
			throw new IllegalArgumentException( "primitive types for src and dest do not match" );
		final boolean fromBuffer = Buffer.class.isAssignableFrom( srcClass );
		final boolean toBuffer = Buffer.class.isAssignableFrom( destClass );
		return forPrimitiveType( primitiveType, fromBuffer, toBuffer );
	}

	/*
	 * -----------------------------------------------------------------------
	 *
	 * Implementations for all combinations of primitive array and Buffer
	 *
	 * -----------------------------------------------------------------------
	 */



	class MemCopyBoolean implements MemCopy< boolean[], boolean[] >
	{
		@Override
		public void copyForward( final boolean[] src, final int srcPos, final boolean[] dest, final int destPos, final int length )
		{
			System.arraycopy( src, srcPos, dest, destPos, length );
		}

		@Override
		public void copyReverse( final boolean[] src, final int srcPos, final boolean[] dest, final int destPos, final int length )
		{
			for ( int i = 0; i < length; ++i )
				dest[ destPos + i ] = src[ srcPos - i ];
		}

		@Override
		public void copyValue( final boolean[] src, final int srcPos, final boolean[] dest, final int destPos, final int length )
		{
			Arrays.fill( dest, destPos, destPos + length, src[ srcPos ] );
		}

		@Override
		public void copyStrided( final boolean[] src, final int srcPos, final boolean[] dest, final int destPos, final int destStride, final int length )
		{
			if ( destStride == 1 )
				copyForward( src, srcPos, dest, destPos, length );
			else
				for ( int i = 0; i < length; ++i )
					dest[ destPos + i * destStride ] = src[ srcPos + i ];
		}
		@Override
		public void copyLines( final int lineDir, final int lineLength, final int numLines, final boolean[] src, final int srcPos, final int srcStep, final boolean[] dest, final int destPos, final int destStep )
		{
			if ( lineDir == 1 )
				for ( int i = 0; i < numLines; ++i )
					copyForward( src, srcPos + i * srcStep, dest, destPos + i * destStep, lineLength );
			else if ( lineDir == -1 )
				for ( int i = 0; i < numLines; ++i )
					copyReverse( src, srcPos + i * srcStep, dest, destPos + i * destStep, lineLength );
			else // cstep0 == 0
				for ( int i = 0; i < numLines; ++i )
					copyValue( src, srcPos + i * srcStep, dest, destPos + i * destStep, lineLength );
		}

		@Override
		public void copyNDRangeRecursive(
			final int d,
			final boolean[] src,
			final int[] srcStrides,
			final int srcPos,
			final boolean[] dest,
			final int[] destStrides,
			final int destPos,
			final int[] size )
		{
			final int len = size[ d ];
			if ( d > 0 )
			{
				final int stride_src = srcStrides[ d ];
				final int stride_dst = destStrides[ d ];
				for ( int i = 0; i < len; ++i )
					copyNDRangeRecursive( d - 1,
							src, srcStrides, srcPos + i * stride_src,
							dest, destStrides, destPos + i * stride_dst,
							size );
			}
			else
				copyForward( src, srcPos, dest, destPos, len );
		}
	}




	class MemCopyByte implements MemCopy< byte[], byte[] >
	{
		@Override
		public void copyForward( final byte[] src, final int srcPos, final byte[] dest, final int destPos, final int length )
		{
			System.arraycopy( src, srcPos, dest, destPos, length );
		}

		@Override
		public void copyReverse( final byte[] src, final int srcPos, final byte[] dest, final int destPos, final int length )
		{
			for ( int i = 0; i < length; ++i )
				dest[ destPos + i ] = src[ srcPos - i ];
		}

		@Override
		public void copyValue( final byte[] src, final int srcPos, final byte[] dest, final int destPos, final int length )
		{
			Arrays.fill( dest, destPos, destPos + length, src[ srcPos ] );
		}

		@Override
		public void copyStrided( final byte[] src, final int srcPos, final byte[] dest, final int destPos, final int destStride, final int length )
		{
			if ( destStride == 1 )
				copyForward( src, srcPos, dest, destPos, length );
			else
				for ( int i = 0; i < length; ++i )
					dest[ destPos + i * destStride ] = src[ srcPos + i ];
		}
		@Override
		public void copyLines( final int lineDir, final int lineLength, final int numLines, final byte[] src, final int srcPos, final int srcStep, final byte[] dest, final int destPos, final int destStep )
		{
			if ( lineDir == 1 )
				for ( int i = 0; i < numLines; ++i )
					copyForward( src, srcPos + i * srcStep, dest, destPos + i * destStep, lineLength );
			else if ( lineDir == -1 )
				for ( int i = 0; i < numLines; ++i )
					copyReverse( src, srcPos + i * srcStep, dest, destPos + i * destStep, lineLength );
			else // cstep0 == 0
				for ( int i = 0; i < numLines; ++i )
					copyValue( src, srcPos + i * srcStep, dest, destPos + i * destStep, lineLength );
		}

		@Override
		public void copyNDRangeRecursive(
			final int d,
			final byte[] src,
			final int[] srcStrides,
			final int srcPos,
			final byte[] dest,
			final int[] destStrides,
			final int destPos,
			final int[] size )
		{
			final int len = size[ d ];
			if ( d > 0 )
			{
				final int stride_src = srcStrides[ d ];
				final int stride_dst = destStrides[ d ];
				for ( int i = 0; i < len; ++i )
					copyNDRangeRecursive( d - 1,
							src, srcStrides, srcPos + i * stride_src,
							dest, destStrides, destPos + i * stride_dst,
							size );
			}
			else
				copyForward( src, srcPos, dest, destPos, len );
		}
	}

	class MemCopyByteBufferToArray implements MemCopy< ByteBuffer, byte[] >
	{
		@Override
		public void copyForward( final ByteBuffer src, final int srcPos, final byte[] dest, final int destPos, final int length )
		{
			src.position( srcPos );
			src.get( dest, destPos, length );
		}

		@Override
		public void copyReverse( final ByteBuffer src, final int srcPos, final byte[] dest, final int destPos, final int length )
		{
			for ( int i = 0; i < length; ++i )
				dest[ destPos + i ] = src.get( srcPos - i );
		}

		@Override
		public void copyValue( final ByteBuffer src, final int srcPos, final byte[] dest, final int destPos, final int length )
		{
			final byte val = src.get( srcPos );
			Arrays.fill( dest, destPos, destPos + length, val );
		}

		@Override
		public void copyStrided( final ByteBuffer src, final int srcPos, final byte[] dest, final int destPos, final int destStride, final int length )
		{
			if ( destStride == 1 )
				copyForward( src, srcPos, dest, destPos, length );
			else
				for ( int i = 0; i < length; ++i )
					dest[ destPos + i * destStride ] = src.get( srcPos + i );
		}

		@Override
		public void copyLines( final int lineDir, final int lineLength, final int numLines, final ByteBuffer src, final int srcPos, final int srcStep, final byte[] dest, final int destPos, final int destStep )
		{
			if ( lineDir == 1 )
				for ( int i = 0; i < numLines; ++i )
					copyForward( src, srcPos + i * srcStep, dest, destPos + i * destStep, lineLength );
			else if ( lineDir == -1 )
				for ( int i = 0; i < numLines; ++i )
					copyReverse( src, srcPos + i * srcStep, dest, destPos + i * destStep, lineLength );
			else // cstep0 == 0
				for ( int i = 0; i < numLines; ++i )
					copyValue( src, srcPos + i * srcStep, dest, destPos + i * destStep, lineLength );
		}

		@Override
		public void copyNDRangeRecursive(
			final int d,
			final ByteBuffer src,
			final int[] srcStrides,
			final int srcPos,
			final byte[] dest,
			final int[] destStrides,
			final int destPos,
			final int[] size )
		{
			final int len = size[ d ];
			if ( d > 0 )
			{
				final int stride_src = srcStrides[ d ];
				final int stride_dst = destStrides[ d ];
				for ( int i = 0; i < len; ++i )
					copyNDRangeRecursive( d - 1,
							src, srcStrides, srcPos + i * stride_src,
							dest, destStrides, destPos + i * stride_dst,
							size );
			}
			else
				copyForward( src, srcPos, dest, destPos, len );
		}
	}

	class MemCopyByteArrayToBuffer implements MemCopy< byte[], ByteBuffer >
	{
		@Override
		public void copyForward( final byte[] src, final int srcPos, final ByteBuffer dest, final int destPos, final int length )
		{
			dest.position( destPos );
			dest.put( src, srcPos, length );
		}

		@Override
		public void copyReverse( final byte[] src, final int srcPos, final ByteBuffer dest, final int destPos, final int length )
		{
			for ( int i = 0; i < length; ++i )
				dest.put( destPos + i, src[ srcPos - i ] );
		}

		@Override
		public void copyValue( final byte[] src, final int srcPos, final ByteBuffer dest, final int destPos, final int length )
		{
			final byte val = src[ srcPos ];
			for ( int i = 0; i < length; ++i )
				dest.put( destPos + i, val );
		}

		@Override
		public void copyStrided( final byte[] src, final int srcPos, final ByteBuffer dest, final int destPos, final int destStride, final int length )
		{
			if ( destStride == 1 )
				copyForward( src, srcPos, dest, destPos, length );
			else
				for ( int i = 0; i < length; ++i )
					dest.put( destPos + i * destStride, src[ srcPos + i ] );
		}

		@Override
		public void copyLines( final int lineDir, final int lineLength, final int numLines, final byte[] src, final int srcPos, final int srcStep, final ByteBuffer dest, final int destPos, final int destStep )
		{
			if ( lineDir == 1 )
				for ( int i = 0; i < numLines; ++i )
					copyForward( src, srcPos + i * srcStep, dest, destPos + i * destStep, lineLength );
			else if ( lineDir == -1 )
				for ( int i = 0; i < numLines; ++i )
					copyReverse( src, srcPos + i * srcStep, dest, destPos + i * destStep, lineLength );
			else // cstep0 == 0
				for ( int i = 0; i < numLines; ++i )
					copyValue( src, srcPos + i * srcStep, dest, destPos + i * destStep, lineLength );
		}

		@Override
		public void copyNDRangeRecursive(
			final int d,
			final byte[] src,
			final int[] srcStrides,
			final int srcPos,
			final ByteBuffer dest,
			final int[] destStrides,
			final int destPos,
			final int[] size )
		{
			final int len = size[ d ];
			if ( d > 0 )
			{
				final int stride_src = srcStrides[ d ];
				final int stride_dst = destStrides[ d ];
				for ( int i = 0; i < len; ++i )
					copyNDRangeRecursive( d - 1,
							src, srcStrides, srcPos + i * stride_src,
							dest, destStrides, destPos + i * stride_dst,
							size );
			}
			else
				copyForward( src, srcPos, dest, destPos, len );
		}
	}

	class MemCopyByteBufferToBuffer implements MemCopy< ByteBuffer, ByteBuffer >
	{
		@Override
		public void copyForward( final ByteBuffer src, final int srcPos, final ByteBuffer dest, final int destPos, final int length )
		{
			src.limit( srcPos + length );
			src.position( srcPos );
			dest.position( destPos );
			dest.put( src );
		}

		@Override
		public void copyReverse( final ByteBuffer src, final int srcPos, final ByteBuffer dest, final int destPos, final int length )
		{
			for ( int i = 0; i < length; ++i )
				dest.put( destPos + i, src.get( srcPos - i ) );
		}

		@Override
		public void copyValue( final ByteBuffer src, final int srcPos, final ByteBuffer dest, final int destPos, final int length )
		{
			final byte val = src.get( srcPos );
			for ( int i = 0; i < length; ++i )
				dest.put( destPos + i, val );
		}

		@Override
		public void copyStrided( final ByteBuffer src, final int srcPos, final ByteBuffer dest, final int destPos, final int destStride, final int length )
		{
			if ( destStride == 1 )
				copyForward( src, srcPos, dest, destPos, length );
			else
				for ( int i = 0; i < length; ++i )
					dest.put( destPos + i * destStride, src.get( srcPos + i ) );
		}

		@Override
		public void copyLines( final int lineDir, final int lineLength, final int numLines, final ByteBuffer src, final int srcPos, final int srcStep, final ByteBuffer dest, final int destPos, final int destStep )
		{
			if ( lineDir == 1 )
				for ( int i = 0; i < numLines; ++i )
					copyForward( src, srcPos + i * srcStep, dest, destPos + i * destStep, lineLength );
			else if ( lineDir == -1 )
				for ( int i = 0; i < numLines; ++i )
					copyReverse( src, srcPos + i * srcStep, dest, destPos + i * destStep, lineLength );
			else // cstep0 == 0
				for ( int i = 0; i < numLines; ++i )
					copyValue( src, srcPos + i * srcStep, dest, destPos + i * destStep, lineLength );
		}

		@Override
		public void copyNDRangeRecursive(
			final int d,
			final ByteBuffer src,
			final int[] srcStrides,
			final int srcPos,
			final ByteBuffer dest,
			final int[] destStrides,
			final int destPos,
			final int[] size )
		{
			final int len = size[ d ];
			if ( d > 0 )
			{
				final int stride_src = srcStrides[ d ];
				final int stride_dst = destStrides[ d ];
				for ( int i = 0; i < len; ++i )
					copyNDRangeRecursive( d - 1,
							src, srcStrides, srcPos + i * stride_src,
							dest, destStrides, destPos + i * stride_dst,
							size );
			}
			else
				copyForward( src, srcPos, dest, destPos, len );
		}
	}




	class MemCopyChar implements MemCopy< char[], char[] >
	{
		@Override
		public void copyForward( final char[] src, final int srcPos, final char[] dest, final int destPos, final int length )
		{
			System.arraycopy( src, srcPos, dest, destPos, length );
		}

		@Override
		public void copyReverse( final char[] src, final int srcPos, final char[] dest, final int destPos, final int length )
		{
			for ( int i = 0; i < length; ++i )
				dest[ destPos + i ] = src[ srcPos - i ];
		}

		@Override
		public void copyValue( final char[] src, final int srcPos, final char[] dest, final int destPos, final int length )
		{
			Arrays.fill( dest, destPos, destPos + length, src[ srcPos ] );
		}

		@Override
		public void copyStrided( final char[] src, final int srcPos, final char[] dest, final int destPos, final int destStride, final int length )
		{
			if ( destStride == 1 )
				copyForward( src, srcPos, dest, destPos, length );
			else
				for ( int i = 0; i < length; ++i )
					dest[ destPos + i * destStride ] = src[ srcPos + i ];
		}
		@Override
		public void copyLines( final int lineDir, final int lineLength, final int numLines, final char[] src, final int srcPos, final int srcStep, final char[] dest, final int destPos, final int destStep )
		{
			if ( lineDir == 1 )
				for ( int i = 0; i < numLines; ++i )
					copyForward( src, srcPos + i * srcStep, dest, destPos + i * destStep, lineLength );
			else if ( lineDir == -1 )
				for ( int i = 0; i < numLines; ++i )
					copyReverse( src, srcPos + i * srcStep, dest, destPos + i * destStep, lineLength );
			else // cstep0 == 0
				for ( int i = 0; i < numLines; ++i )
					copyValue( src, srcPos + i * srcStep, dest, destPos + i * destStep, lineLength );
		}

		@Override
		public void copyNDRangeRecursive(
			final int d,
			final char[] src,
			final int[] srcStrides,
			final int srcPos,
			final char[] dest,
			final int[] destStrides,
			final int destPos,
			final int[] size )
		{
			final int len = size[ d ];
			if ( d > 0 )
			{
				final int stride_src = srcStrides[ d ];
				final int stride_dst = destStrides[ d ];
				for ( int i = 0; i < len; ++i )
					copyNDRangeRecursive( d - 1,
							src, srcStrides, srcPos + i * stride_src,
							dest, destStrides, destPos + i * stride_dst,
							size );
			}
			else
				copyForward( src, srcPos, dest, destPos, len );
		}
	}

	class MemCopyCharBufferToArray implements MemCopy< CharBuffer, char[] >
	{
		@Override
		public void copyForward( final CharBuffer src, final int srcPos, final char[] dest, final int destPos, final int length )
		{
			src.position( srcPos );
			src.get( dest, destPos, length );
		}

		@Override
		public void copyReverse( final CharBuffer src, final int srcPos, final char[] dest, final int destPos, final int length )
		{
			for ( int i = 0; i < length; ++i )
				dest[ destPos + i ] = src.get( srcPos - i );
		}

		@Override
		public void copyValue( final CharBuffer src, final int srcPos, final char[] dest, final int destPos, final int length )
		{
			final char val = src.get( srcPos );
			Arrays.fill( dest, destPos, destPos + length, val );
		}

		@Override
		public void copyStrided( final CharBuffer src, final int srcPos, final char[] dest, final int destPos, final int destStride, final int length )
		{
			if ( destStride == 1 )
				copyForward( src, srcPos, dest, destPos, length );
			else
				for ( int i = 0; i < length; ++i )
					dest[ destPos + i * destStride ] = src.get( srcPos + i );
		}

		@Override
		public void copyLines( final int lineDir, final int lineLength, final int numLines, final CharBuffer src, final int srcPos, final int srcStep, final char[] dest, final int destPos, final int destStep )
		{
			if ( lineDir == 1 )
				for ( int i = 0; i < numLines; ++i )
					copyForward( src, srcPos + i * srcStep, dest, destPos + i * destStep, lineLength );
			else if ( lineDir == -1 )
				for ( int i = 0; i < numLines; ++i )
					copyReverse( src, srcPos + i * srcStep, dest, destPos + i * destStep, lineLength );
			else // cstep0 == 0
				for ( int i = 0; i < numLines; ++i )
					copyValue( src, srcPos + i * srcStep, dest, destPos + i * destStep, lineLength );
		}

		@Override
		public void copyNDRangeRecursive(
			final int d,
			final CharBuffer src,
			final int[] srcStrides,
			final int srcPos,
			final char[] dest,
			final int[] destStrides,
			final int destPos,
			final int[] size )
		{
			final int len = size[ d ];
			if ( d > 0 )
			{
				final int stride_src = srcStrides[ d ];
				final int stride_dst = destStrides[ d ];
				for ( int i = 0; i < len; ++i )
					copyNDRangeRecursive( d - 1,
							src, srcStrides, srcPos + i * stride_src,
							dest, destStrides, destPos + i * stride_dst,
							size );
			}
			else
				copyForward( src, srcPos, dest, destPos, len );
		}
	}

	class MemCopyCharArrayToBuffer implements MemCopy< char[], CharBuffer >
	{
		@Override
		public void copyForward( final char[] src, final int srcPos, final CharBuffer dest, final int destPos, final int length )
		{
			dest.position( destPos );
			dest.put( src, srcPos, length );
		}

		@Override
		public void copyReverse( final char[] src, final int srcPos, final CharBuffer dest, final int destPos, final int length )
		{
			for ( int i = 0; i < length; ++i )
				dest.put( destPos + i, src[ srcPos - i ] );
		}

		@Override
		public void copyValue( final char[] src, final int srcPos, final CharBuffer dest, final int destPos, final int length )
		{
			final char val = src[ srcPos ];
			for ( int i = 0; i < length; ++i )
				dest.put( destPos + i, val );
		}

		@Override
		public void copyStrided( final char[] src, final int srcPos, final CharBuffer dest, final int destPos, final int destStride, final int length )
		{
			if ( destStride == 1 )
				copyForward( src, srcPos, dest, destPos, length );
			else
				for ( int i = 0; i < length; ++i )
					dest.put( destPos + i * destStride, src[ srcPos + i ] );
		}

		@Override
		public void copyLines( final int lineDir, final int lineLength, final int numLines, final char[] src, final int srcPos, final int srcStep, final CharBuffer dest, final int destPos, final int destStep )
		{
			if ( lineDir == 1 )
				for ( int i = 0; i < numLines; ++i )
					copyForward( src, srcPos + i * srcStep, dest, destPos + i * destStep, lineLength );
			else if ( lineDir == -1 )
				for ( int i = 0; i < numLines; ++i )
					copyReverse( src, srcPos + i * srcStep, dest, destPos + i * destStep, lineLength );
			else // cstep0 == 0
				for ( int i = 0; i < numLines; ++i )
					copyValue( src, srcPos + i * srcStep, dest, destPos + i * destStep, lineLength );
		}

		@Override
		public void copyNDRangeRecursive(
			final int d,
			final char[] src,
			final int[] srcStrides,
			final int srcPos,
			final CharBuffer dest,
			final int[] destStrides,
			final int destPos,
			final int[] size )
		{
			final int len = size[ d ];
			if ( d > 0 )
			{
				final int stride_src = srcStrides[ d ];
				final int stride_dst = destStrides[ d ];
				for ( int i = 0; i < len; ++i )
					copyNDRangeRecursive( d - 1,
							src, srcStrides, srcPos + i * stride_src,
							dest, destStrides, destPos + i * stride_dst,
							size );
			}
			else
				copyForward( src, srcPos, dest, destPos, len );
		}
	}

	class MemCopyCharBufferToBuffer implements MemCopy< CharBuffer, CharBuffer >
	{
		@Override
		public void copyForward( final CharBuffer src, final int srcPos, final CharBuffer dest, final int destPos, final int length )
		{
			src.limit( srcPos + length );
			src.position( srcPos );
			dest.position( destPos );
			dest.put( src );
		}

		@Override
		public void copyReverse( final CharBuffer src, final int srcPos, final CharBuffer dest, final int destPos, final int length )
		{
			for ( int i = 0; i < length; ++i )
				dest.put( destPos + i, src.get( srcPos - i ) );
		}

		@Override
		public void copyValue( final CharBuffer src, final int srcPos, final CharBuffer dest, final int destPos, final int length )
		{
			final char val = src.get( srcPos );
			for ( int i = 0; i < length; ++i )
				dest.put( destPos + i, val );
		}

		@Override
		public void copyStrided( final CharBuffer src, final int srcPos, final CharBuffer dest, final int destPos, final int destStride, final int length )
		{
			if ( destStride == 1 )
				copyForward( src, srcPos, dest, destPos, length );
			else
				for ( int i = 0; i < length; ++i )
					dest.put( destPos + i * destStride, src.get( srcPos + i ) );
		}

		@Override
		public void copyLines( final int lineDir, final int lineLength, final int numLines, final CharBuffer src, final int srcPos, final int srcStep, final CharBuffer dest, final int destPos, final int destStep )
		{
			if ( lineDir == 1 )
				for ( int i = 0; i < numLines; ++i )
					copyForward( src, srcPos + i * srcStep, dest, destPos + i * destStep, lineLength );
			else if ( lineDir == -1 )
				for ( int i = 0; i < numLines; ++i )
					copyReverse( src, srcPos + i * srcStep, dest, destPos + i * destStep, lineLength );
			else // cstep0 == 0
				for ( int i = 0; i < numLines; ++i )
					copyValue( src, srcPos + i * srcStep, dest, destPos + i * destStep, lineLength );
		}

		@Override
		public void copyNDRangeRecursive(
			final int d,
			final CharBuffer src,
			final int[] srcStrides,
			final int srcPos,
			final CharBuffer dest,
			final int[] destStrides,
			final int destPos,
			final int[] size )
		{
			final int len = size[ d ];
			if ( d > 0 )
			{
				final int stride_src = srcStrides[ d ];
				final int stride_dst = destStrides[ d ];
				for ( int i = 0; i < len; ++i )
					copyNDRangeRecursive( d - 1,
							src, srcStrides, srcPos + i * stride_src,
							dest, destStrides, destPos + i * stride_dst,
							size );
			}
			else
				copyForward( src, srcPos, dest, destPos, len );
		}
	}




	class MemCopyShort implements MemCopy< short[], short[] >
	{
		@Override
		public void copyForward( final short[] src, final int srcPos, final short[] dest, final int destPos, final int length )
		{
			System.arraycopy( src, srcPos, dest, destPos, length );
		}

		@Override
		public void copyReverse( final short[] src, final int srcPos, final short[] dest, final int destPos, final int length )
		{
			for ( int i = 0; i < length; ++i )
				dest[ destPos + i ] = src[ srcPos - i ];
		}

		@Override
		public void copyValue( final short[] src, final int srcPos, final short[] dest, final int destPos, final int length )
		{
			Arrays.fill( dest, destPos, destPos + length, src[ srcPos ] );
		}

		@Override
		public void copyStrided( final short[] src, final int srcPos, final short[] dest, final int destPos, final int destStride, final int length )
		{
			if ( destStride == 1 )
				copyForward( src, srcPos, dest, destPos, length );
			else
				for ( int i = 0; i < length; ++i )
					dest[ destPos + i * destStride ] = src[ srcPos + i ];
		}
		@Override
		public void copyLines( final int lineDir, final int lineLength, final int numLines, final short[] src, final int srcPos, final int srcStep, final short[] dest, final int destPos, final int destStep )
		{
			if ( lineDir == 1 )
				for ( int i = 0; i < numLines; ++i )
					copyForward( src, srcPos + i * srcStep, dest, destPos + i * destStep, lineLength );
			else if ( lineDir == -1 )
				for ( int i = 0; i < numLines; ++i )
					copyReverse( src, srcPos + i * srcStep, dest, destPos + i * destStep, lineLength );
			else // cstep0 == 0
				for ( int i = 0; i < numLines; ++i )
					copyValue( src, srcPos + i * srcStep, dest, destPos + i * destStep, lineLength );
		}

		@Override
		public void copyNDRangeRecursive(
			final int d,
			final short[] src,
			final int[] srcStrides,
			final int srcPos,
			final short[] dest,
			final int[] destStrides,
			final int destPos,
			final int[] size )
		{
			final int len = size[ d ];
			if ( d > 0 )
			{
				final int stride_src = srcStrides[ d ];
				final int stride_dst = destStrides[ d ];
				for ( int i = 0; i < len; ++i )
					copyNDRangeRecursive( d - 1,
							src, srcStrides, srcPos + i * stride_src,
							dest, destStrides, destPos + i * stride_dst,
							size );
			}
			else
				copyForward( src, srcPos, dest, destPos, len );
		}
	}

	class MemCopyShortBufferToArray implements MemCopy< ShortBuffer, short[] >
	{
		@Override
		public void copyForward( final ShortBuffer src, final int srcPos, final short[] dest, final int destPos, final int length )
		{
			src.position( srcPos );
			src.get( dest, destPos, length );
		}

		@Override
		public void copyReverse( final ShortBuffer src, final int srcPos, final short[] dest, final int destPos, final int length )
		{
			for ( int i = 0; i < length; ++i )
				dest[ destPos + i ] = src.get( srcPos - i );
		}

		@Override
		public void copyValue( final ShortBuffer src, final int srcPos, final short[] dest, final int destPos, final int length )
		{
			final short val = src.get( srcPos );
			Arrays.fill( dest, destPos, destPos + length, val );
		}

		@Override
		public void copyStrided( final ShortBuffer src, final int srcPos, final short[] dest, final int destPos, final int destStride, final int length )
		{
			if ( destStride == 1 )
				copyForward( src, srcPos, dest, destPos, length );
			else
				for ( int i = 0; i < length; ++i )
					dest[ destPos + i * destStride ] = src.get( srcPos + i );
		}

		@Override
		public void copyLines( final int lineDir, final int lineLength, final int numLines, final ShortBuffer src, final int srcPos, final int srcStep, final short[] dest, final int destPos, final int destStep )
		{
			if ( lineDir == 1 )
				for ( int i = 0; i < numLines; ++i )
					copyForward( src, srcPos + i * srcStep, dest, destPos + i * destStep, lineLength );
			else if ( lineDir == -1 )
				for ( int i = 0; i < numLines; ++i )
					copyReverse( src, srcPos + i * srcStep, dest, destPos + i * destStep, lineLength );
			else // cstep0 == 0
				for ( int i = 0; i < numLines; ++i )
					copyValue( src, srcPos + i * srcStep, dest, destPos + i * destStep, lineLength );
		}

		@Override
		public void copyNDRangeRecursive(
			final int d,
			final ShortBuffer src,
			final int[] srcStrides,
			final int srcPos,
			final short[] dest,
			final int[] destStrides,
			final int destPos,
			final int[] size )
		{
			final int len = size[ d ];
			if ( d > 0 )
			{
				final int stride_src = srcStrides[ d ];
				final int stride_dst = destStrides[ d ];
				for ( int i = 0; i < len; ++i )
					copyNDRangeRecursive( d - 1,
							src, srcStrides, srcPos + i * stride_src,
							dest, destStrides, destPos + i * stride_dst,
							size );
			}
			else
				copyForward( src, srcPos, dest, destPos, len );
		}
	}

	class MemCopyShortArrayToBuffer implements MemCopy< short[], ShortBuffer >
	{
		@Override
		public void copyForward( final short[] src, final int srcPos, final ShortBuffer dest, final int destPos, final int length )
		{
			dest.position( destPos );
			dest.put( src, srcPos, length );
		}

		@Override
		public void copyReverse( final short[] src, final int srcPos, final ShortBuffer dest, final int destPos, final int length )
		{
			for ( int i = 0; i < length; ++i )
				dest.put( destPos + i, src[ srcPos - i ] );
		}

		@Override
		public void copyValue( final short[] src, final int srcPos, final ShortBuffer dest, final int destPos, final int length )
		{
			final short val = src[ srcPos ];
			for ( int i = 0; i < length; ++i )
				dest.put( destPos + i, val );
		}

		@Override
		public void copyStrided( final short[] src, final int srcPos, final ShortBuffer dest, final int destPos, final int destStride, final int length )
		{
			if ( destStride == 1 )
				copyForward( src, srcPos, dest, destPos, length );
			else
				for ( int i = 0; i < length; ++i )
					dest.put( destPos + i * destStride, src[ srcPos + i ] );
		}

		@Override
		public void copyLines( final int lineDir, final int lineLength, final int numLines, final short[] src, final int srcPos, final int srcStep, final ShortBuffer dest, final int destPos, final int destStep )
		{
			if ( lineDir == 1 )
				for ( int i = 0; i < numLines; ++i )
					copyForward( src, srcPos + i * srcStep, dest, destPos + i * destStep, lineLength );
			else if ( lineDir == -1 )
				for ( int i = 0; i < numLines; ++i )
					copyReverse( src, srcPos + i * srcStep, dest, destPos + i * destStep, lineLength );
			else // cstep0 == 0
				for ( int i = 0; i < numLines; ++i )
					copyValue( src, srcPos + i * srcStep, dest, destPos + i * destStep, lineLength );
		}

		@Override
		public void copyNDRangeRecursive(
			final int d,
			final short[] src,
			final int[] srcStrides,
			final int srcPos,
			final ShortBuffer dest,
			final int[] destStrides,
			final int destPos,
			final int[] size )
		{
			final int len = size[ d ];
			if ( d > 0 )
			{
				final int stride_src = srcStrides[ d ];
				final int stride_dst = destStrides[ d ];
				for ( int i = 0; i < len; ++i )
					copyNDRangeRecursive( d - 1,
							src, srcStrides, srcPos + i * stride_src,
							dest, destStrides, destPos + i * stride_dst,
							size );
			}
			else
				copyForward( src, srcPos, dest, destPos, len );
		}
	}

	class MemCopyShortBufferToBuffer implements MemCopy< ShortBuffer, ShortBuffer >
	{
		@Override
		public void copyForward( final ShortBuffer src, final int srcPos, final ShortBuffer dest, final int destPos, final int length )
		{
			src.limit( srcPos + length );
			src.position( srcPos );
			dest.position( destPos );
			dest.put( src );
		}

		@Override
		public void copyReverse( final ShortBuffer src, final int srcPos, final ShortBuffer dest, final int destPos, final int length )
		{
			for ( int i = 0; i < length; ++i )
				dest.put( destPos + i, src.get( srcPos - i ) );
		}

		@Override
		public void copyValue( final ShortBuffer src, final int srcPos, final ShortBuffer dest, final int destPos, final int length )
		{
			final short val = src.get( srcPos );
			for ( int i = 0; i < length; ++i )
				dest.put( destPos + i, val );
		}

		@Override
		public void copyStrided( final ShortBuffer src, final int srcPos, final ShortBuffer dest, final int destPos, final int destStride, final int length )
		{
			if ( destStride == 1 )
				copyForward( src, srcPos, dest, destPos, length );
			else
				for ( int i = 0; i < length; ++i )
					dest.put( destPos + i * destStride, src.get( srcPos + i ) );
		}

		@Override
		public void copyLines( final int lineDir, final int lineLength, final int numLines, final ShortBuffer src, final int srcPos, final int srcStep, final ShortBuffer dest, final int destPos, final int destStep )
		{
			if ( lineDir == 1 )
				for ( int i = 0; i < numLines; ++i )
					copyForward( src, srcPos + i * srcStep, dest, destPos + i * destStep, lineLength );
			else if ( lineDir == -1 )
				for ( int i = 0; i < numLines; ++i )
					copyReverse( src, srcPos + i * srcStep, dest, destPos + i * destStep, lineLength );
			else // cstep0 == 0
				for ( int i = 0; i < numLines; ++i )
					copyValue( src, srcPos + i * srcStep, dest, destPos + i * destStep, lineLength );
		}

		@Override
		public void copyNDRangeRecursive(
			final int d,
			final ShortBuffer src,
			final int[] srcStrides,
			final int srcPos,
			final ShortBuffer dest,
			final int[] destStrides,
			final int destPos,
			final int[] size )
		{
			final int len = size[ d ];
			if ( d > 0 )
			{
				final int stride_src = srcStrides[ d ];
				final int stride_dst = destStrides[ d ];
				for ( int i = 0; i < len; ++i )
					copyNDRangeRecursive( d - 1,
							src, srcStrides, srcPos + i * stride_src,
							dest, destStrides, destPos + i * stride_dst,
							size );
			}
			else
				copyForward( src, srcPos, dest, destPos, len );
		}
	}




	class MemCopyInt implements MemCopy< int[], int[] >
	{
		@Override
		public void copyForward( final int[] src, final int srcPos, final int[] dest, final int destPos, final int length )
		{
			System.arraycopy( src, srcPos, dest, destPos, length );
		}

		@Override
		public void copyReverse( final int[] src, final int srcPos, final int[] dest, final int destPos, final int length )
		{
			for ( int i = 0; i < length; ++i )
				dest[ destPos + i ] = src[ srcPos - i ];
		}

		@Override
		public void copyValue( final int[] src, final int srcPos, final int[] dest, final int destPos, final int length )
		{
			Arrays.fill( dest, destPos, destPos + length, src[ srcPos ] );
		}

		@Override
		public void copyStrided( final int[] src, final int srcPos, final int[] dest, final int destPos, final int destStride, final int length )
		{
			if ( destStride == 1 )
				copyForward( src, srcPos, dest, destPos, length );
			else
				for ( int i = 0; i < length; ++i )
					dest[ destPos + i * destStride ] = src[ srcPos + i ];
		}
		@Override
		public void copyLines( final int lineDir, final int lineLength, final int numLines, final int[] src, final int srcPos, final int srcStep, final int[] dest, final int destPos, final int destStep )
		{
			if ( lineDir == 1 )
				for ( int i = 0; i < numLines; ++i )
					copyForward( src, srcPos + i * srcStep, dest, destPos + i * destStep, lineLength );
			else if ( lineDir == -1 )
				for ( int i = 0; i < numLines; ++i )
					copyReverse( src, srcPos + i * srcStep, dest, destPos + i * destStep, lineLength );
			else // cstep0 == 0
				for ( int i = 0; i < numLines; ++i )
					copyValue( src, srcPos + i * srcStep, dest, destPos + i * destStep, lineLength );
		}

		@Override
		public void copyNDRangeRecursive(
			final int d,
			final int[] src,
			final int[] srcStrides,
			final int srcPos,
			final int[] dest,
			final int[] destStrides,
			final int destPos,
			final int[] size )
		{
			final int len = size[ d ];
			if ( d > 0 )
			{
				final int stride_src = srcStrides[ d ];
				final int stride_dst = destStrides[ d ];
				for ( int i = 0; i < len; ++i )
					copyNDRangeRecursive( d - 1,
							src, srcStrides, srcPos + i * stride_src,
							dest, destStrides, destPos + i * stride_dst,
							size );
			}
			else
				copyForward( src, srcPos, dest, destPos, len );
		}
	}

	class MemCopyIntBufferToArray implements MemCopy< IntBuffer, int[] >
	{
		@Override
		public void copyForward( final IntBuffer src, final int srcPos, final int[] dest, final int destPos, final int length )
		{
			src.position( srcPos );
			src.get( dest, destPos, length );
		}

		@Override
		public void copyReverse( final IntBuffer src, final int srcPos, final int[] dest, final int destPos, final int length )
		{
			for ( int i = 0; i < length; ++i )
				dest[ destPos + i ] = src.get( srcPos - i );
		}

		@Override
		public void copyValue( final IntBuffer src, final int srcPos, final int[] dest, final int destPos, final int length )
		{
			final int val = src.get( srcPos );
			Arrays.fill( dest, destPos, destPos + length, val );
		}

		@Override
		public void copyStrided( final IntBuffer src, final int srcPos, final int[] dest, final int destPos, final int destStride, final int length )
		{
			if ( destStride == 1 )
				copyForward( src, srcPos, dest, destPos, length );
			else
				for ( int i = 0; i < length; ++i )
					dest[ destPos + i * destStride ] = src.get( srcPos + i );
		}

		@Override
		public void copyLines( final int lineDir, final int lineLength, final int numLines, final IntBuffer src, final int srcPos, final int srcStep, final int[] dest, final int destPos, final int destStep )
		{
			if ( lineDir == 1 )
				for ( int i = 0; i < numLines; ++i )
					copyForward( src, srcPos + i * srcStep, dest, destPos + i * destStep, lineLength );
			else if ( lineDir == -1 )
				for ( int i = 0; i < numLines; ++i )
					copyReverse( src, srcPos + i * srcStep, dest, destPos + i * destStep, lineLength );
			else // cstep0 == 0
				for ( int i = 0; i < numLines; ++i )
					copyValue( src, srcPos + i * srcStep, dest, destPos + i * destStep, lineLength );
		}

		@Override
		public void copyNDRangeRecursive(
			final int d,
			final IntBuffer src,
			final int[] srcStrides,
			final int srcPos,
			final int[] dest,
			final int[] destStrides,
			final int destPos,
			final int[] size )
		{
			final int len = size[ d ];
			if ( d > 0 )
			{
				final int stride_src = srcStrides[ d ];
				final int stride_dst = destStrides[ d ];
				for ( int i = 0; i < len; ++i )
					copyNDRangeRecursive( d - 1,
							src, srcStrides, srcPos + i * stride_src,
							dest, destStrides, destPos + i * stride_dst,
							size );
			}
			else
				copyForward( src, srcPos, dest, destPos, len );
		}
	}

	class MemCopyIntArrayToBuffer implements MemCopy< int[], IntBuffer >
	{
		@Override
		public void copyForward( final int[] src, final int srcPos, final IntBuffer dest, final int destPos, final int length )
		{
			dest.position( destPos );
			dest.put( src, srcPos, length );
		}

		@Override
		public void copyReverse( final int[] src, final int srcPos, final IntBuffer dest, final int destPos, final int length )
		{
			for ( int i = 0; i < length; ++i )
				dest.put( destPos + i, src[ srcPos - i ] );
		}

		@Override
		public void copyValue( final int[] src, final int srcPos, final IntBuffer dest, final int destPos, final int length )
		{
			final int val = src[ srcPos ];
			for ( int i = 0; i < length; ++i )
				dest.put( destPos + i, val );
		}

		@Override
		public void copyStrided( final int[] src, final int srcPos, final IntBuffer dest, final int destPos, final int destStride, final int length )
		{
			if ( destStride == 1 )
				copyForward( src, srcPos, dest, destPos, length );
			else
				for ( int i = 0; i < length; ++i )
					dest.put( destPos + i * destStride, src[ srcPos + i ] );
		}

		@Override
		public void copyLines( final int lineDir, final int lineLength, final int numLines, final int[] src, final int srcPos, final int srcStep, final IntBuffer dest, final int destPos, final int destStep )
		{
			if ( lineDir == 1 )
				for ( int i = 0; i < numLines; ++i )
					copyForward( src, srcPos + i * srcStep, dest, destPos + i * destStep, lineLength );
			else if ( lineDir == -1 )
				for ( int i = 0; i < numLines; ++i )
					copyReverse( src, srcPos + i * srcStep, dest, destPos + i * destStep, lineLength );
			else // cstep0 == 0
				for ( int i = 0; i < numLines; ++i )
					copyValue( src, srcPos + i * srcStep, dest, destPos + i * destStep, lineLength );
		}

		@Override
		public void copyNDRangeRecursive(
			final int d,
			final int[] src,
			final int[] srcStrides,
			final int srcPos,
			final IntBuffer dest,
			final int[] destStrides,
			final int destPos,
			final int[] size )
		{
			final int len = size[ d ];
			if ( d > 0 )
			{
				final int stride_src = srcStrides[ d ];
				final int stride_dst = destStrides[ d ];
				for ( int i = 0; i < len; ++i )
					copyNDRangeRecursive( d - 1,
							src, srcStrides, srcPos + i * stride_src,
							dest, destStrides, destPos + i * stride_dst,
							size );
			}
			else
				copyForward( src, srcPos, dest, destPos, len );
		}
	}

	class MemCopyIntBufferToBuffer implements MemCopy< IntBuffer, IntBuffer >
	{
		@Override
		public void copyForward( final IntBuffer src, final int srcPos, final IntBuffer dest, final int destPos, final int length )
		{
			src.limit( srcPos + length );
			src.position( srcPos );
			dest.position( destPos );
			dest.put( src );
		}

		@Override
		public void copyReverse( final IntBuffer src, final int srcPos, final IntBuffer dest, final int destPos, final int length )
		{
			for ( int i = 0; i < length; ++i )
				dest.put( destPos + i, src.get( srcPos - i ) );
		}

		@Override
		public void copyValue( final IntBuffer src, final int srcPos, final IntBuffer dest, final int destPos, final int length )
		{
			final int val = src.get( srcPos );
			for ( int i = 0; i < length; ++i )
				dest.put( destPos + i, val );
		}

		@Override
		public void copyStrided( final IntBuffer src, final int srcPos, final IntBuffer dest, final int destPos, final int destStride, final int length )
		{
			if ( destStride == 1 )
				copyForward( src, srcPos, dest, destPos, length );
			else
				for ( int i = 0; i < length; ++i )
					dest.put( destPos + i * destStride, src.get( srcPos + i ) );
		}

		@Override
		public void copyLines( final int lineDir, final int lineLength, final int numLines, final IntBuffer src, final int srcPos, final int srcStep, final IntBuffer dest, final int destPos, final int destStep )
		{
			if ( lineDir == 1 )
				for ( int i = 0; i < numLines; ++i )
					copyForward( src, srcPos + i * srcStep, dest, destPos + i * destStep, lineLength );
			else if ( lineDir == -1 )
				for ( int i = 0; i < numLines; ++i )
					copyReverse( src, srcPos + i * srcStep, dest, destPos + i * destStep, lineLength );
			else // cstep0 == 0
				for ( int i = 0; i < numLines; ++i )
					copyValue( src, srcPos + i * srcStep, dest, destPos + i * destStep, lineLength );
		}

		@Override
		public void copyNDRangeRecursive(
			final int d,
			final IntBuffer src,
			final int[] srcStrides,
			final int srcPos,
			final IntBuffer dest,
			final int[] destStrides,
			final int destPos,
			final int[] size )
		{
			final int len = size[ d ];
			if ( d > 0 )
			{
				final int stride_src = srcStrides[ d ];
				final int stride_dst = destStrides[ d ];
				for ( int i = 0; i < len; ++i )
					copyNDRangeRecursive( d - 1,
							src, srcStrides, srcPos + i * stride_src,
							dest, destStrides, destPos + i * stride_dst,
							size );
			}
			else
				copyForward( src, srcPos, dest, destPos, len );
		}
	}




	class MemCopyLong implements MemCopy< long[], long[] >
	{
		@Override
		public void copyForward( final long[] src, final int srcPos, final long[] dest, final int destPos, final int length )
		{
			System.arraycopy( src, srcPos, dest, destPos, length );
		}

		@Override
		public void copyReverse( final long[] src, final int srcPos, final long[] dest, final int destPos, final int length )
		{
			for ( int i = 0; i < length; ++i )
				dest[ destPos + i ] = src[ srcPos - i ];
		}

		@Override
		public void copyValue( final long[] src, final int srcPos, final long[] dest, final int destPos, final int length )
		{
			Arrays.fill( dest, destPos, destPos + length, src[ srcPos ] );
		}

		@Override
		public void copyStrided( final long[] src, final int srcPos, final long[] dest, final int destPos, final int destStride, final int length )
		{
			if ( destStride == 1 )
				copyForward( src, srcPos, dest, destPos, length );
			else
				for ( int i = 0; i < length; ++i )
					dest[ destPos + i * destStride ] = src[ srcPos + i ];
		}
		@Override
		public void copyLines( final int lineDir, final int lineLength, final int numLines, final long[] src, final int srcPos, final int srcStep, final long[] dest, final int destPos, final int destStep )
		{
			if ( lineDir == 1 )
				for ( int i = 0; i < numLines; ++i )
					copyForward( src, srcPos + i * srcStep, dest, destPos + i * destStep, lineLength );
			else if ( lineDir == -1 )
				for ( int i = 0; i < numLines; ++i )
					copyReverse( src, srcPos + i * srcStep, dest, destPos + i * destStep, lineLength );
			else // cstep0 == 0
				for ( int i = 0; i < numLines; ++i )
					copyValue( src, srcPos + i * srcStep, dest, destPos + i * destStep, lineLength );
		}

		@Override
		public void copyNDRangeRecursive(
			final int d,
			final long[] src,
			final int[] srcStrides,
			final int srcPos,
			final long[] dest,
			final int[] destStrides,
			final int destPos,
			final int[] size )
		{
			final int len = size[ d ];
			if ( d > 0 )
			{
				final int stride_src = srcStrides[ d ];
				final int stride_dst = destStrides[ d ];
				for ( int i = 0; i < len; ++i )
					copyNDRangeRecursive( d - 1,
							src, srcStrides, srcPos + i * stride_src,
							dest, destStrides, destPos + i * stride_dst,
							size );
			}
			else
				copyForward( src, srcPos, dest, destPos, len );
		}
	}

	class MemCopyLongBufferToArray implements MemCopy< LongBuffer, long[] >
	{
		@Override
		public void copyForward( final LongBuffer src, final int srcPos, final long[] dest, final int destPos, final int length )
		{
			src.position( srcPos );
			src.get( dest, destPos, length );
		}

		@Override
		public void copyReverse( final LongBuffer src, final int srcPos, final long[] dest, final int destPos, final int length )
		{
			for ( int i = 0; i < length; ++i )
				dest[ destPos + i ] = src.get( srcPos - i );
		}

		@Override
		public void copyValue( final LongBuffer src, final int srcPos, final long[] dest, final int destPos, final int length )
		{
			final long val = src.get( srcPos );
			Arrays.fill( dest, destPos, destPos + length, val );
		}

		@Override
		public void copyStrided( final LongBuffer src, final int srcPos, final long[] dest, final int destPos, final int destStride, final int length )
		{
			if ( destStride == 1 )
				copyForward( src, srcPos, dest, destPos, length );
			else
				for ( int i = 0; i < length; ++i )
					dest[ destPos + i * destStride ] = src.get( srcPos + i );
		}

		@Override
		public void copyLines( final int lineDir, final int lineLength, final int numLines, final LongBuffer src, final int srcPos, final int srcStep, final long[] dest, final int destPos, final int destStep )
		{
			if ( lineDir == 1 )
				for ( int i = 0; i < numLines; ++i )
					copyForward( src, srcPos + i * srcStep, dest, destPos + i * destStep, lineLength );
			else if ( lineDir == -1 )
				for ( int i = 0; i < numLines; ++i )
					copyReverse( src, srcPos + i * srcStep, dest, destPos + i * destStep, lineLength );
			else // cstep0 == 0
				for ( int i = 0; i < numLines; ++i )
					copyValue( src, srcPos + i * srcStep, dest, destPos + i * destStep, lineLength );
		}

		@Override
		public void copyNDRangeRecursive(
			final int d,
			final LongBuffer src,
			final int[] srcStrides,
			final int srcPos,
			final long[] dest,
			final int[] destStrides,
			final int destPos,
			final int[] size )
		{
			final int len = size[ d ];
			if ( d > 0 )
			{
				final int stride_src = srcStrides[ d ];
				final int stride_dst = destStrides[ d ];
				for ( int i = 0; i < len; ++i )
					copyNDRangeRecursive( d - 1,
							src, srcStrides, srcPos + i * stride_src,
							dest, destStrides, destPos + i * stride_dst,
							size );
			}
			else
				copyForward( src, srcPos, dest, destPos, len );
		}
	}

	class MemCopyLongArrayToBuffer implements MemCopy< long[], LongBuffer >
	{
		@Override
		public void copyForward( final long[] src, final int srcPos, final LongBuffer dest, final int destPos, final int length )
		{
			dest.position( destPos );
			dest.put( src, srcPos, length );
		}

		@Override
		public void copyReverse( final long[] src, final int srcPos, final LongBuffer dest, final int destPos, final int length )
		{
			for ( int i = 0; i < length; ++i )
				dest.put( destPos + i, src[ srcPos - i ] );
		}

		@Override
		public void copyValue( final long[] src, final int srcPos, final LongBuffer dest, final int destPos, final int length )
		{
			final long val = src[ srcPos ];
			for ( int i = 0; i < length; ++i )
				dest.put( destPos + i, val );
		}

		@Override
		public void copyStrided( final long[] src, final int srcPos, final LongBuffer dest, final int destPos, final int destStride, final int length )
		{
			if ( destStride == 1 )
				copyForward( src, srcPos, dest, destPos, length );
			else
				for ( int i = 0; i < length; ++i )
					dest.put( destPos + i * destStride, src[ srcPos + i ] );
		}

		@Override
		public void copyLines( final int lineDir, final int lineLength, final int numLines, final long[] src, final int srcPos, final int srcStep, final LongBuffer dest, final int destPos, final int destStep )
		{
			if ( lineDir == 1 )
				for ( int i = 0; i < numLines; ++i )
					copyForward( src, srcPos + i * srcStep, dest, destPos + i * destStep, lineLength );
			else if ( lineDir == -1 )
				for ( int i = 0; i < numLines; ++i )
					copyReverse( src, srcPos + i * srcStep, dest, destPos + i * destStep, lineLength );
			else // cstep0 == 0
				for ( int i = 0; i < numLines; ++i )
					copyValue( src, srcPos + i * srcStep, dest, destPos + i * destStep, lineLength );
		}

		@Override
		public void copyNDRangeRecursive(
			final int d,
			final long[] src,
			final int[] srcStrides,
			final int srcPos,
			final LongBuffer dest,
			final int[] destStrides,
			final int destPos,
			final int[] size )
		{
			final int len = size[ d ];
			if ( d > 0 )
			{
				final int stride_src = srcStrides[ d ];
				final int stride_dst = destStrides[ d ];
				for ( int i = 0; i < len; ++i )
					copyNDRangeRecursive( d - 1,
							src, srcStrides, srcPos + i * stride_src,
							dest, destStrides, destPos + i * stride_dst,
							size );
			}
			else
				copyForward( src, srcPos, dest, destPos, len );
		}
	}

	class MemCopyLongBufferToBuffer implements MemCopy< LongBuffer, LongBuffer >
	{
		@Override
		public void copyForward( final LongBuffer src, final int srcPos, final LongBuffer dest, final int destPos, final int length )
		{
			src.limit( srcPos + length );
			src.position( srcPos );
			dest.position( destPos );
			dest.put( src );
		}

		@Override
		public void copyReverse( final LongBuffer src, final int srcPos, final LongBuffer dest, final int destPos, final int length )
		{
			for ( int i = 0; i < length; ++i )
				dest.put( destPos + i, src.get( srcPos - i ) );
		}

		@Override
		public void copyValue( final LongBuffer src, final int srcPos, final LongBuffer dest, final int destPos, final int length )
		{
			final long val = src.get( srcPos );
			for ( int i = 0; i < length; ++i )
				dest.put( destPos + i, val );
		}

		@Override
		public void copyStrided( final LongBuffer src, final int srcPos, final LongBuffer dest, final int destPos, final int destStride, final int length )
		{
			if ( destStride == 1 )
				copyForward( src, srcPos, dest, destPos, length );
			else
				for ( int i = 0; i < length; ++i )
					dest.put( destPos + i * destStride, src.get( srcPos + i ) );
		}

		@Override
		public void copyLines( final int lineDir, final int lineLength, final int numLines, final LongBuffer src, final int srcPos, final int srcStep, final LongBuffer dest, final int destPos, final int destStep )
		{
			if ( lineDir == 1 )
				for ( int i = 0; i < numLines; ++i )
					copyForward( src, srcPos + i * srcStep, dest, destPos + i * destStep, lineLength );
			else if ( lineDir == -1 )
				for ( int i = 0; i < numLines; ++i )
					copyReverse( src, srcPos + i * srcStep, dest, destPos + i * destStep, lineLength );
			else // cstep0 == 0
				for ( int i = 0; i < numLines; ++i )
					copyValue( src, srcPos + i * srcStep, dest, destPos + i * destStep, lineLength );
		}

		@Override
		public void copyNDRangeRecursive(
			final int d,
			final LongBuffer src,
			final int[] srcStrides,
			final int srcPos,
			final LongBuffer dest,
			final int[] destStrides,
			final int destPos,
			final int[] size )
		{
			final int len = size[ d ];
			if ( d > 0 )
			{
				final int stride_src = srcStrides[ d ];
				final int stride_dst = destStrides[ d ];
				for ( int i = 0; i < len; ++i )
					copyNDRangeRecursive( d - 1,
							src, srcStrides, srcPos + i * stride_src,
							dest, destStrides, destPos + i * stride_dst,
							size );
			}
			else
				copyForward( src, srcPos, dest, destPos, len );
		}
	}




	class MemCopyFloat implements MemCopy< float[], float[] >
	{
		@Override
		public void copyForward( final float[] src, final int srcPos, final float[] dest, final int destPos, final int length )
		{
			System.arraycopy( src, srcPos, dest, destPos, length );
		}

		@Override
		public void copyReverse( final float[] src, final int srcPos, final float[] dest, final int destPos, final int length )
		{
			for ( int i = 0; i < length; ++i )
				dest[ destPos + i ] = src[ srcPos - i ];
		}

		@Override
		public void copyValue( final float[] src, final int srcPos, final float[] dest, final int destPos, final int length )
		{
			Arrays.fill( dest, destPos, destPos + length, src[ srcPos ] );
		}

		@Override
		public void copyStrided( final float[] src, final int srcPos, final float[] dest, final int destPos, final int destStride, final int length )
		{
			if ( destStride == 1 )
				copyForward( src, srcPos, dest, destPos, length );
			else
				for ( int i = 0; i < length; ++i )
					dest[ destPos + i * destStride ] = src[ srcPos + i ];
		}
		@Override
		public void copyLines( final int lineDir, final int lineLength, final int numLines, final float[] src, final int srcPos, final int srcStep, final float[] dest, final int destPos, final int destStep )
		{
			if ( lineDir == 1 )
				for ( int i = 0; i < numLines; ++i )
					copyForward( src, srcPos + i * srcStep, dest, destPos + i * destStep, lineLength );
			else if ( lineDir == -1 )
				for ( int i = 0; i < numLines; ++i )
					copyReverse( src, srcPos + i * srcStep, dest, destPos + i * destStep, lineLength );
			else // cstep0 == 0
				for ( int i = 0; i < numLines; ++i )
					copyValue( src, srcPos + i * srcStep, dest, destPos + i * destStep, lineLength );
		}

		@Override
		public void copyNDRangeRecursive(
			final int d,
			final float[] src,
			final int[] srcStrides,
			final int srcPos,
			final float[] dest,
			final int[] destStrides,
			final int destPos,
			final int[] size )
		{
			final int len = size[ d ];
			if ( d > 0 )
			{
				final int stride_src = srcStrides[ d ];
				final int stride_dst = destStrides[ d ];
				for ( int i = 0; i < len; ++i )
					copyNDRangeRecursive( d - 1,
							src, srcStrides, srcPos + i * stride_src,
							dest, destStrides, destPos + i * stride_dst,
							size );
			}
			else
				copyForward( src, srcPos, dest, destPos, len );
		}
	}

	class MemCopyFloatBufferToArray implements MemCopy< FloatBuffer, float[] >
	{
		@Override
		public void copyForward( final FloatBuffer src, final int srcPos, final float[] dest, final int destPos, final int length )
		{
			src.position( srcPos );
			src.get( dest, destPos, length );
		}

		@Override
		public void copyReverse( final FloatBuffer src, final int srcPos, final float[] dest, final int destPos, final int length )
		{
			for ( int i = 0; i < length; ++i )
				dest[ destPos + i ] = src.get( srcPos - i );
		}

		@Override
		public void copyValue( final FloatBuffer src, final int srcPos, final float[] dest, final int destPos, final int length )
		{
			final float val = src.get( srcPos );
			Arrays.fill( dest, destPos, destPos + length, val );
		}

		@Override
		public void copyStrided( final FloatBuffer src, final int srcPos, final float[] dest, final int destPos, final int destStride, final int length )
		{
			if ( destStride == 1 )
				copyForward( src, srcPos, dest, destPos, length );
			else
				for ( int i = 0; i < length; ++i )
					dest[ destPos + i * destStride ] = src.get( srcPos + i );
		}

		@Override
		public void copyLines( final int lineDir, final int lineLength, final int numLines, final FloatBuffer src, final int srcPos, final int srcStep, final float[] dest, final int destPos, final int destStep )
		{
			if ( lineDir == 1 )
				for ( int i = 0; i < numLines; ++i )
					copyForward( src, srcPos + i * srcStep, dest, destPos + i * destStep, lineLength );
			else if ( lineDir == -1 )
				for ( int i = 0; i < numLines; ++i )
					copyReverse( src, srcPos + i * srcStep, dest, destPos + i * destStep, lineLength );
			else // cstep0 == 0
				for ( int i = 0; i < numLines; ++i )
					copyValue( src, srcPos + i * srcStep, dest, destPos + i * destStep, lineLength );
		}

		@Override
		public void copyNDRangeRecursive(
			final int d,
			final FloatBuffer src,
			final int[] srcStrides,
			final int srcPos,
			final float[] dest,
			final int[] destStrides,
			final int destPos,
			final int[] size )
		{
			final int len = size[ d ];
			if ( d > 0 )
			{
				final int stride_src = srcStrides[ d ];
				final int stride_dst = destStrides[ d ];
				for ( int i = 0; i < len; ++i )
					copyNDRangeRecursive( d - 1,
							src, srcStrides, srcPos + i * stride_src,
							dest, destStrides, destPos + i * stride_dst,
							size );
			}
			else
				copyForward( src, srcPos, dest, destPos, len );
		}
	}

	class MemCopyFloatArrayToBuffer implements MemCopy< float[], FloatBuffer >
	{
		@Override
		public void copyForward( final float[] src, final int srcPos, final FloatBuffer dest, final int destPos, final int length )
		{
			dest.position( destPos );
			dest.put( src, srcPos, length );
		}

		@Override
		public void copyReverse( final float[] src, final int srcPos, final FloatBuffer dest, final int destPos, final int length )
		{
			for ( int i = 0; i < length; ++i )
				dest.put( destPos + i, src[ srcPos - i ] );
		}

		@Override
		public void copyValue( final float[] src, final int srcPos, final FloatBuffer dest, final int destPos, final int length )
		{
			final float val = src[ srcPos ];
			for ( int i = 0; i < length; ++i )
				dest.put( destPos + i, val );
		}

		@Override
		public void copyStrided( final float[] src, final int srcPos, final FloatBuffer dest, final int destPos, final int destStride, final int length )
		{
			if ( destStride == 1 )
				copyForward( src, srcPos, dest, destPos, length );
			else
				for ( int i = 0; i < length; ++i )
					dest.put( destPos + i * destStride, src[ srcPos + i ] );
		}

		@Override
		public void copyLines( final int lineDir, final int lineLength, final int numLines, final float[] src, final int srcPos, final int srcStep, final FloatBuffer dest, final int destPos, final int destStep )
		{
			if ( lineDir == 1 )
				for ( int i = 0; i < numLines; ++i )
					copyForward( src, srcPos + i * srcStep, dest, destPos + i * destStep, lineLength );
			else if ( lineDir == -1 )
				for ( int i = 0; i < numLines; ++i )
					copyReverse( src, srcPos + i * srcStep, dest, destPos + i * destStep, lineLength );
			else // cstep0 == 0
				for ( int i = 0; i < numLines; ++i )
					copyValue( src, srcPos + i * srcStep, dest, destPos + i * destStep, lineLength );
		}

		@Override
		public void copyNDRangeRecursive(
			final int d,
			final float[] src,
			final int[] srcStrides,
			final int srcPos,
			final FloatBuffer dest,
			final int[] destStrides,
			final int destPos,
			final int[] size )
		{
			final int len = size[ d ];
			if ( d > 0 )
			{
				final int stride_src = srcStrides[ d ];
				final int stride_dst = destStrides[ d ];
				for ( int i = 0; i < len; ++i )
					copyNDRangeRecursive( d - 1,
							src, srcStrides, srcPos + i * stride_src,
							dest, destStrides, destPos + i * stride_dst,
							size );
			}
			else
				copyForward( src, srcPos, dest, destPos, len );
		}
	}

	class MemCopyFloatBufferToBuffer implements MemCopy< FloatBuffer, FloatBuffer >
	{
		@Override
		public void copyForward( final FloatBuffer src, final int srcPos, final FloatBuffer dest, final int destPos, final int length )
		{
			src.limit( srcPos + length );
			src.position( srcPos );
			dest.position( destPos );
			dest.put( src );
		}

		@Override
		public void copyReverse( final FloatBuffer src, final int srcPos, final FloatBuffer dest, final int destPos, final int length )
		{
			for ( int i = 0; i < length; ++i )
				dest.put( destPos + i, src.get( srcPos - i ) );
		}

		@Override
		public void copyValue( final FloatBuffer src, final int srcPos, final FloatBuffer dest, final int destPos, final int length )
		{
			final float val = src.get( srcPos );
			for ( int i = 0; i < length; ++i )
				dest.put( destPos + i, val );
		}

		@Override
		public void copyStrided( final FloatBuffer src, final int srcPos, final FloatBuffer dest, final int destPos, final int destStride, final int length )
		{
			if ( destStride == 1 )
				copyForward( src, srcPos, dest, destPos, length );
			else
				for ( int i = 0; i < length; ++i )
					dest.put( destPos + i * destStride, src.get( srcPos + i ) );
		}

		@Override
		public void copyLines( final int lineDir, final int lineLength, final int numLines, final FloatBuffer src, final int srcPos, final int srcStep, final FloatBuffer dest, final int destPos, final int destStep )
		{
			if ( lineDir == 1 )
				for ( int i = 0; i < numLines; ++i )
					copyForward( src, srcPos + i * srcStep, dest, destPos + i * destStep, lineLength );
			else if ( lineDir == -1 )
				for ( int i = 0; i < numLines; ++i )
					copyReverse( src, srcPos + i * srcStep, dest, destPos + i * destStep, lineLength );
			else // cstep0 == 0
				for ( int i = 0; i < numLines; ++i )
					copyValue( src, srcPos + i * srcStep, dest, destPos + i * destStep, lineLength );
		}

		@Override
		public void copyNDRangeRecursive(
			final int d,
			final FloatBuffer src,
			final int[] srcStrides,
			final int srcPos,
			final FloatBuffer dest,
			final int[] destStrides,
			final int destPos,
			final int[] size )
		{
			final int len = size[ d ];
			if ( d > 0 )
			{
				final int stride_src = srcStrides[ d ];
				final int stride_dst = destStrides[ d ];
				for ( int i = 0; i < len; ++i )
					copyNDRangeRecursive( d - 1,
							src, srcStrides, srcPos + i * stride_src,
							dest, destStrides, destPos + i * stride_dst,
							size );
			}
			else
				copyForward( src, srcPos, dest, destPos, len );
		}
	}




	class MemCopyDouble implements MemCopy< double[], double[] >
	{
		@Override
		public void copyForward( final double[] src, final int srcPos, final double[] dest, final int destPos, final int length )
		{
			System.arraycopy( src, srcPos, dest, destPos, length );
		}

		@Override
		public void copyReverse( final double[] src, final int srcPos, final double[] dest, final int destPos, final int length )
		{
			for ( int i = 0; i < length; ++i )
				dest[ destPos + i ] = src[ srcPos - i ];
		}

		@Override
		public void copyValue( final double[] src, final int srcPos, final double[] dest, final int destPos, final int length )
		{
			Arrays.fill( dest, destPos, destPos + length, src[ srcPos ] );
		}

		@Override
		public void copyStrided( final double[] src, final int srcPos, final double[] dest, final int destPos, final int destStride, final int length )
		{
			if ( destStride == 1 )
				copyForward( src, srcPos, dest, destPos, length );
			else
				for ( int i = 0; i < length; ++i )
					dest[ destPos + i * destStride ] = src[ srcPos + i ];
		}
		@Override
		public void copyLines( final int lineDir, final int lineLength, final int numLines, final double[] src, final int srcPos, final int srcStep, final double[] dest, final int destPos, final int destStep )
		{
			if ( lineDir == 1 )
				for ( int i = 0; i < numLines; ++i )
					copyForward( src, srcPos + i * srcStep, dest, destPos + i * destStep, lineLength );
			else if ( lineDir == -1 )
				for ( int i = 0; i < numLines; ++i )
					copyReverse( src, srcPos + i * srcStep, dest, destPos + i * destStep, lineLength );
			else // cstep0 == 0
				for ( int i = 0; i < numLines; ++i )
					copyValue( src, srcPos + i * srcStep, dest, destPos + i * destStep, lineLength );
		}

		@Override
		public void copyNDRangeRecursive(
			final int d,
			final double[] src,
			final int[] srcStrides,
			final int srcPos,
			final double[] dest,
			final int[] destStrides,
			final int destPos,
			final int[] size )
		{
			final int len = size[ d ];
			if ( d > 0 )
			{
				final int stride_src = srcStrides[ d ];
				final int stride_dst = destStrides[ d ];
				for ( int i = 0; i < len; ++i )
					copyNDRangeRecursive( d - 1,
							src, srcStrides, srcPos + i * stride_src,
							dest, destStrides, destPos + i * stride_dst,
							size );
			}
			else
				copyForward( src, srcPos, dest, destPos, len );
		}
	}

	class MemCopyDoubleBufferToArray implements MemCopy< DoubleBuffer, double[] >
	{
		@Override
		public void copyForward( final DoubleBuffer src, final int srcPos, final double[] dest, final int destPos, final int length )
		{
			src.position( srcPos );
			src.get( dest, destPos, length );
		}

		@Override
		public void copyReverse( final DoubleBuffer src, final int srcPos, final double[] dest, final int destPos, final int length )
		{
			for ( int i = 0; i < length; ++i )
				dest[ destPos + i ] = src.get( srcPos - i );
		}

		@Override
		public void copyValue( final DoubleBuffer src, final int srcPos, final double[] dest, final int destPos, final int length )
		{
			final double val = src.get( srcPos );
			Arrays.fill( dest, destPos, destPos + length, val );
		}

		@Override
		public void copyStrided( final DoubleBuffer src, final int srcPos, final double[] dest, final int destPos, final int destStride, final int length )
		{
			if ( destStride == 1 )
				copyForward( src, srcPos, dest, destPos, length );
			else
				for ( int i = 0; i < length; ++i )
					dest[ destPos + i * destStride ] = src.get( srcPos + i );
		}

		@Override
		public void copyLines( final int lineDir, final int lineLength, final int numLines, final DoubleBuffer src, final int srcPos, final int srcStep, final double[] dest, final int destPos, final int destStep )
		{
			if ( lineDir == 1 )
				for ( int i = 0; i < numLines; ++i )
					copyForward( src, srcPos + i * srcStep, dest, destPos + i * destStep, lineLength );
			else if ( lineDir == -1 )
				for ( int i = 0; i < numLines; ++i )
					copyReverse( src, srcPos + i * srcStep, dest, destPos + i * destStep, lineLength );
			else // cstep0 == 0
				for ( int i = 0; i < numLines; ++i )
					copyValue( src, srcPos + i * srcStep, dest, destPos + i * destStep, lineLength );
		}

		@Override
		public void copyNDRangeRecursive(
			final int d,
			final DoubleBuffer src,
			final int[] srcStrides,
			final int srcPos,
			final double[] dest,
			final int[] destStrides,
			final int destPos,
			final int[] size )
		{
			final int len = size[ d ];
			if ( d > 0 )
			{
				final int stride_src = srcStrides[ d ];
				final int stride_dst = destStrides[ d ];
				for ( int i = 0; i < len; ++i )
					copyNDRangeRecursive( d - 1,
							src, srcStrides, srcPos + i * stride_src,
							dest, destStrides, destPos + i * stride_dst,
							size );
			}
			else
				copyForward( src, srcPos, dest, destPos, len );
		}
	}

	class MemCopyDoubleArrayToBuffer implements MemCopy< double[], DoubleBuffer >
	{
		@Override
		public void copyForward( final double[] src, final int srcPos, final DoubleBuffer dest, final int destPos, final int length )
		{
			dest.position( destPos );
			dest.put( src, srcPos, length );
		}

		@Override
		public void copyReverse( final double[] src, final int srcPos, final DoubleBuffer dest, final int destPos, final int length )
		{
			for ( int i = 0; i < length; ++i )
				dest.put( destPos + i, src[ srcPos - i ] );
		}

		@Override
		public void copyValue( final double[] src, final int srcPos, final DoubleBuffer dest, final int destPos, final int length )
		{
			final double val = src[ srcPos ];
			for ( int i = 0; i < length; ++i )
				dest.put( destPos + i, val );
		}

		@Override
		public void copyStrided( final double[] src, final int srcPos, final DoubleBuffer dest, final int destPos, final int destStride, final int length )
		{
			if ( destStride == 1 )
				copyForward( src, srcPos, dest, destPos, length );
			else
				for ( int i = 0; i < length; ++i )
					dest.put( destPos + i * destStride, src[ srcPos + i ] );
		}

		@Override
		public void copyLines( final int lineDir, final int lineLength, final int numLines, final double[] src, final int srcPos, final int srcStep, final DoubleBuffer dest, final int destPos, final int destStep )
		{
			if ( lineDir == 1 )
				for ( int i = 0; i < numLines; ++i )
					copyForward( src, srcPos + i * srcStep, dest, destPos + i * destStep, lineLength );
			else if ( lineDir == -1 )
				for ( int i = 0; i < numLines; ++i )
					copyReverse( src, srcPos + i * srcStep, dest, destPos + i * destStep, lineLength );
			else // cstep0 == 0
				for ( int i = 0; i < numLines; ++i )
					copyValue( src, srcPos + i * srcStep, dest, destPos + i * destStep, lineLength );
		}

		@Override
		public void copyNDRangeRecursive(
			final int d,
			final double[] src,
			final int[] srcStrides,
			final int srcPos,
			final DoubleBuffer dest,
			final int[] destStrides,
			final int destPos,
			final int[] size )
		{
			final int len = size[ d ];
			if ( d > 0 )
			{
				final int stride_src = srcStrides[ d ];
				final int stride_dst = destStrides[ d ];
				for ( int i = 0; i < len; ++i )
					copyNDRangeRecursive( d - 1,
							src, srcStrides, srcPos + i * stride_src,
							dest, destStrides, destPos + i * stride_dst,
							size );
			}
			else
				copyForward( src, srcPos, dest, destPos, len );
		}
	}

	class MemCopyDoubleBufferToBuffer implements MemCopy< DoubleBuffer, DoubleBuffer >
	{
		@Override
		public void copyForward( final DoubleBuffer src, final int srcPos, final DoubleBuffer dest, final int destPos, final int length )
		{
			src.limit( srcPos + length );
			src.position( srcPos );
			dest.position( destPos );
			dest.put( src );
		}

		@Override
		public void copyReverse( final DoubleBuffer src, final int srcPos, final DoubleBuffer dest, final int destPos, final int length )
		{
			for ( int i = 0; i < length; ++i )
				dest.put( destPos + i, src.get( srcPos - i ) );
		}

		@Override
		public void copyValue( final DoubleBuffer src, final int srcPos, final DoubleBuffer dest, final int destPos, final int length )
		{
			final double val = src.get( srcPos );
			for ( int i = 0; i < length; ++i )
				dest.put( destPos + i, val );
		}

		@Override
		public void copyStrided( final DoubleBuffer src, final int srcPos, final DoubleBuffer dest, final int destPos, final int destStride, final int length )
		{
			if ( destStride == 1 )
				copyForward( src, srcPos, dest, destPos, length );
			else
				for ( int i = 0; i < length; ++i )
					dest.put( destPos + i * destStride, src.get( srcPos + i ) );
		}

		@Override
		public void copyLines( final int lineDir, final int lineLength, final int numLines, final DoubleBuffer src, final int srcPos, final int srcStep, final DoubleBuffer dest, final int destPos, final int destStep )
		{
			if ( lineDir == 1 )
				for ( int i = 0; i < numLines; ++i )
					copyForward( src, srcPos + i * srcStep, dest, destPos + i * destStep, lineLength );
			else if ( lineDir == -1 )
				for ( int i = 0; i < numLines; ++i )
					copyReverse( src, srcPos + i * srcStep, dest, destPos + i * destStep, lineLength );
			else // cstep0 == 0
				for ( int i = 0; i < numLines; ++i )
					copyValue( src, srcPos + i * srcStep, dest, destPos + i * destStep, lineLength );
		}

		@Override
		public void copyNDRangeRecursive(
			final int d,
			final DoubleBuffer src,
			final int[] srcStrides,
			final int srcPos,
			final DoubleBuffer dest,
			final int[] destStrides,
			final int destPos,
			final int[] size )
		{
			final int len = size[ d ];
			if ( d > 0 )
			{
				final int stride_src = srcStrides[ d ];
				final int stride_dst = destStrides[ d ];
				for ( int i = 0; i < len; ++i )
					copyNDRangeRecursive( d - 1,
							src, srcStrides, srcPos + i * stride_src,
							dest, destStrides, destPos + i * stride_dst,
							size );
			}
			else
				copyForward( src, srcPos, dest, destPos, len );
		}
	}

}
