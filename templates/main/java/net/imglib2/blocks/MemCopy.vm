/*-
 * #%L
 * ImgLib2: a general-purpose, multidimensional image processing library.
 * %%
 * Copyright (C) 2009 - 2024 Tobias Pietzsch, Stephan Preibisch, Stephan Saalfeld,
 * John Bogovic, Albert Cardona, Barry DeZonia, Christian Dietz, Jan Funke,
 * Aivar Grislis, Jonathan Hale, Grant Harris, Stefan Helfrich, Mark Hiner,
 * Martin Horn, Steffen Jaensch, Lee Kamentsky, Larry Lindsey, Melissa Linkert,
 * Mark Longair, Brian Northan, Nick Perry, Curtis Rueden, Johannes Schindelin,
 * Jean-Yves Tinevez and Michael Zinsmaier.
 * %%
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 * #L%
 */
package net.imglib2.blocks;

import java.nio.Buffer;
import java.nio.ByteBuffer;
import java.nio.CharBuffer;
import java.nio.DoubleBuffer;
import java.nio.FloatBuffer;
import java.nio.IntBuffer;
import java.nio.LongBuffer;
import java.nio.ShortBuffer;
import java.util.Arrays;

import net.imglib2.type.PrimitiveType;

/*
 * This is autogenerated source code -- DO NOT EDIT. Instead, edit the
 * corresponding template in templates/ and rerun bin/generate.groovy.
 */

// TODO javadoc
// low-level copying methods
// implementations for all primitive types
// T is a primitive array type

/**
 * Low-level range copying methods between source {@code S} and target {@code T}
 * which can be either primitive array types (e.g., {@code double[]}) or the
 * corresponding {@code Buffer} (e.g., {@code DoubleBuffer}).
 * <p>
 * All combinations are implemented (e.g., {@code byte[]}-to-{@code byte[]},
 * {@code byte[]}-to-{@code ByteBuffer}, {@code ByteBuffer}-to-{@code byte[]},
 * and {@code ByteBuffer}-to-{@code ByteBuffer}).
 *
 * @param <S>
 * 		the source type. Must be a primitive array or buffer type (e.g., {@code double[]} or {@code IntBuffer})
 * @param <T>
 * 		the target type. Must be a primitive array or buffer type (e.g., {@code double[]} or {@code IntBuffer})
 */
interface MemCopy< S, T >
{
	/**
	 * Copy {@code length} components from the {@code src} array to the {@code
	 * dest} array. The components at positions {@code srcPos} through {@code
	 * srcPos+length-1} in the source array are copied into positions {@code
	 * destPos} through {@code destPos+length-1}, respectively, of the
	 * destination array.
	 */
	void copyForward( S src, int srcPos, T dest, int destPos, int length );

	/**
	 * Copy {@code length} components from the {@code src} array to the {@code
	 * dest} array, in reverse order. The components at positions {@code srcPos}
	 * through {@code srcPos-length-1} in the source array are copied into
	 * positions {@code destPos} through {@code destPos+length-1}, respectively,
	 * of the destination array.
	 */
	void copyReverse( S src, int srcPos, T dest, int destPos, int length );

	/**
	 * Copy component at position {@code srcPos} in the {@code src} array
	 * ({@code length} times) into positions {@code destPos} through {@code
	 * destPos+length-1} of the destination array.
	 */
	void copyValue( S src, int srcPos, T dest, int destPos, int length );

	/**
	 * Copy {@code length} components from the {@code src} array to the {@code
	 * dest} array. The components at positions {@code srcPos} through {@code
	 * srcPos+length-1} in the source array are copied into positions {@code
	 * destPos}, {@code destPos+destStride}, {@code destPos + 2*destStride},
	 * etc., through {@code destPos+(length-1)*destStride} of the destination
	 * array.
	 */
	void copyStrided( S src, int srcPos, T dest, int destPos, int destStride, int length );

	/**
	 * Copy {@code numLines} stretches of {@code lineLength} elements.
	 *
	 * @param lineDir {@code 1}, {@code -1}, or {@code 0}. This corresponds (for every line being copied) to the source position moving forward, backward, or not at all, as the dest position is moving forward.
	 * @param lineLength how many elements to copy per line
	 * @param numLines how many lines to copy
	 * @param src source array
	 * @param srcPos starting position in source array
	 * @param srcStep offset to next line in src
	 * @param dest dest array
	 * @param destPos starting position in dest array
	 * @param destStep offset to next line in dest
	 */
	// Note that this default implementation is overridden in each
	// implementation (with identical code) to soften the performance hit from
	// polymorphism. The default implementation is left here, to make additional
	// implementations easier.
	default void copyLines(
			final int lineDir,
			final int lineLength,
			final int numLines,
			final S src,
			final int srcPos,
			final int srcStep,
			final T dest,
			final int destPos,
			final int destStep )
	{
		if ( lineDir == 1 )
			for ( int i = 0; i < numLines; ++i )
				copyForward( src, srcPos + i * srcStep, dest, destPos + i * destStep, lineLength );
		else if ( lineDir == -1 )
			for ( int i = 0; i < numLines; ++i )
				copyReverse( src, srcPos + i * srcStep, dest, destPos + i * destStep, lineLength );
		else // cstep0 == 0
			for ( int i = 0; i < numLines; ++i )
				copyValue( src, srcPos + i * srcStep, dest, destPos + i * destStep, lineLength );
	}

	/**
	 * Recursively copy a {@code (d+1)} dimensional region from {@code src} to
	 * {@code dest}, where {@code src} and {@code dest} are flattened nD array
	 * with strides {@code srcStrides} and {@code destStrides}, respectively.
	 * <p>
	 * For {@code d=0}, a 1D line of length {@code size[0]} is copied
	 * (equivalent to {@code System.arraycopy}). For {@code d=1}, a 2D plane of
	 * size {@code size[0] * size[1]} is copied, by recursively copying 1D
	 * lines, starting {@code srcStrides[1]} (respectively {@code
	 * destStrides[1]}) apart. For {@code d=2}, a 3D box is copied by
	 * recursively copying 2D planes, etc.
	 *
	 * @param d
	 * 		current dimension
	 * @param src
	 * 		flattened nD source array
	 * @param srcStrides
	 *      nD strides of src
	 * @param srcPos
	 * 		flattened index (in src) to start copying from
	 * @param dest
	 * 		flattened nD destination array
	 * @param destStrides
	 *      nD strides of dest
	 * @param destPos
	 * 		flattened index (in dest) to start copying to
	 * @param size
	 * 		nD size of the range to copy
	 */
	// Note that this default implementation is overridden in each
	// implementation (with identical code) to soften the performance hit from
	// polymorphism. The default implementation is left here, to make additional
	// implementations easier.
	default void copyNDRangeRecursive(
			final int d,
			final S src,
			final int[] srcStrides,
			final int srcPos,
			final T dest,
			final int[] destStrides,
			final int destPos,
			final int[] size )
	{
		final int len = size[ d ];
		if ( d > 0 )
		{
			final int stride_src = srcStrides[ d ];
			final int stride_dst = destStrides[ d ];
			for ( int i = 0; i < len; ++i )
				copyNDRangeRecursive( d - 1,
						src, srcStrides, srcPos + i * stride_src,
						dest, destStrides, destPos + i * stride_dst,
						size );
		}
		else
			copyForward( src, srcPos, dest, destPos, len );
	}

	MemCopyBoolean BOOLEAN = new MemCopyBoolean();
	MemCopyByte BYTE = new MemCopyByte();
	MemCopyChar CHAR = new MemCopyChar();
	MemCopyShort SHORT = new MemCopyShort();
	MemCopyInt INT = new MemCopyInt();
	MemCopyLong LONG = new MemCopyLong();
	MemCopyFloat FLOAT = new MemCopyFloat();
	MemCopyDouble DOUBLE = new MemCopyDouble();

	MemCopyByteBufferToArray BUFFER_TO_ARRAY_BYTE = new MemCopyByteBufferToArray();
	MemCopyCharBufferToArray BUFFER_TO_ARRAY_CHAR = new MemCopyCharBufferToArray();
	MemCopyShortBufferToArray BUFFER_TO_ARRAY_SHORT = new MemCopyShortBufferToArray();
	MemCopyIntBufferToArray BUFFER_TO_ARRAY_INT = new MemCopyIntBufferToArray();
	MemCopyLongBufferToArray BUFFER_TO_ARRAY_LONG = new MemCopyLongBufferToArray();
	MemCopyFloatBufferToArray BUFFER_TO_ARRAY_FLOAT = new MemCopyFloatBufferToArray();
	MemCopyDoubleBufferToArray BUFFER_TO_ARRAY_DOUBLE = new MemCopyDoubleBufferToArray();

	MemCopyByteArrayToBuffer ARRAY_TO_BUFFER_BYTE = new MemCopyByteArrayToBuffer();
	MemCopyCharArrayToBuffer ARRAY_TO_BUFFER_CHAR = new MemCopyCharArrayToBuffer();
	MemCopyShortArrayToBuffer ARRAY_TO_BUFFER_SHORT = new MemCopyShortArrayToBuffer();
	MemCopyIntArrayToBuffer ARRAY_TO_BUFFER_INT = new MemCopyIntArrayToBuffer();
	MemCopyLongArrayToBuffer ARRAY_TO_BUFFER_LONG = new MemCopyLongArrayToBuffer();
	MemCopyFloatArrayToBuffer ARRAY_TO_BUFFER_FLOAT = new MemCopyFloatArrayToBuffer();
	MemCopyDoubleArrayToBuffer ARRAY_TO_BUFFER_DOUBLE = new MemCopyDoubleArrayToBuffer();

	MemCopyByteBufferToBuffer BUFFER_TO_BUFFER_BYTE = new MemCopyByteBufferToBuffer();
	MemCopyCharBufferToBuffer BUFFER_TO_BUFFER_CHAR = new MemCopyCharBufferToBuffer();
	MemCopyShortBufferToBuffer BUFFER_TO_BUFFER_SHORT = new MemCopyShortBufferToBuffer();
	MemCopyIntBufferToBuffer BUFFER_TO_BUFFER_INT = new MemCopyIntBufferToBuffer();
	MemCopyLongBufferToBuffer BUFFER_TO_BUFFER_LONG = new MemCopyLongBufferToBuffer();
	MemCopyFloatBufferToBuffer BUFFER_TO_BUFFER_FLOAT = new MemCopyFloatBufferToBuffer();
	MemCopyDoubleBufferToBuffer BUFFER_TO_BUFFER_DOUBLE = new MemCopyDoubleBufferToBuffer();

	static MemCopy< ?, ? > forPrimitiveType( final PrimitiveType primitiveType )
	{
		return forPrimitiveType( primitiveType, false, false );
	}

	static MemCopy< ?, ? > forPrimitiveType( final PrimitiveType primitiveType, final boolean fromBuffer, final boolean toBuffer )
	{
		switch ( primitiveType )
		{
		case BOOLEAN:
			if ( fromBuffer || toBuffer )
				throw new IllegalArgumentException( "No BufferAccess implementation for PrimitiveType.BOOLEAN" );
			else
				return BOOLEAN;
		case BYTE:
			return fromBuffer
					? ( toBuffer ? BUFFER_TO_BUFFER_BYTE : BUFFER_TO_ARRAY_BYTE )
					: ( toBuffer ? ARRAY_TO_BUFFER_BYTE : BYTE );
		case CHAR:
			return fromBuffer
					? ( toBuffer ? BUFFER_TO_BUFFER_CHAR : BUFFER_TO_ARRAY_CHAR )
					: ( toBuffer ? ARRAY_TO_BUFFER_CHAR : CHAR );
		case SHORT:
			return fromBuffer
					? ( toBuffer ? BUFFER_TO_BUFFER_SHORT : BUFFER_TO_ARRAY_SHORT )
					: ( toBuffer ? ARRAY_TO_BUFFER_SHORT : SHORT );
		case INT:
			return fromBuffer
					? ( toBuffer ? BUFFER_TO_BUFFER_INT : BUFFER_TO_ARRAY_INT )
					: ( toBuffer ? ARRAY_TO_BUFFER_INT : INT );
		case LONG:
			return fromBuffer
					? ( toBuffer ? BUFFER_TO_BUFFER_LONG : BUFFER_TO_ARRAY_LONG )
					: ( toBuffer ? ARRAY_TO_BUFFER_LONG : LONG );
		case FLOAT:
			return fromBuffer
					? ( toBuffer ? BUFFER_TO_BUFFER_FLOAT : BUFFER_TO_ARRAY_FLOAT )
					: ( toBuffer ? ARRAY_TO_BUFFER_FLOAT : FLOAT );
		case DOUBLE:
			return fromBuffer
					? ( toBuffer ? BUFFER_TO_BUFFER_DOUBLE : BUFFER_TO_ARRAY_DOUBLE )
					: ( toBuffer ? ARRAY_TO_BUFFER_DOUBLE : DOUBLE );
		default:
		case UNDEFINED:
			throw new IllegalArgumentException();
		}
	}


	// TODO: Remove?
	static PrimitiveType primitiveTypeForClass( final Class< ? > clz )
	{
		if ( clz.equals( boolean[].class ) )
			return PrimitiveType.BOOLEAN;
		else if ( clz.equals( byte[].class ) || clz.equals( ByteBuffer.class ) )
			return PrimitiveType.BYTE;
		else if ( clz.equals( char[].class ) || clz.equals( CharBuffer.class ) )
			return PrimitiveType.CHAR;
		else if ( clz.equals( short[].class ) || clz.equals( ShortBuffer.class ) )
			return PrimitiveType.SHORT;
		else if ( clz.equals( int[].class ) || clz.equals( IntBuffer.class ) )
			return PrimitiveType.INT;
		else if ( clz.equals( long[].class ) || clz.equals( LongBuffer.class ) )
			return PrimitiveType.LONG;
		else if ( clz.equals( float[].class ) || clz.equals( FloatBuffer.class ) )
			return PrimitiveType.FLOAT;
		else if ( clz.equals( double[].class ) || clz.equals( DoubleBuffer.class ) )
			return PrimitiveType.DOUBLE;
		else
			throw new IllegalArgumentException();
	}

	// TODO: Remove?
	static MemCopy< ?, ? > forClasses( final Class< ? > srcClass, final Class< ? > destClass )
	{
		final PrimitiveType primitiveType = primitiveTypeForClass( srcClass );
		if ( !primitiveTypeForClass( destClass ).equals( primitiveType ) )
			throw new IllegalArgumentException( "primitive types for src and dest do not match" );
		final boolean fromBuffer = Buffer.class.isAssignableFrom( srcClass );
		final boolean toBuffer = Buffer.class.isAssignableFrom( destClass );
		return forPrimitiveType( primitiveType, fromBuffer, toBuffer );
	}

	/*
	 * -----------------------------------------------------------------------
	 *
	 * Implementations for all combinations of primitive array and Buffer
	 *
	 * -----------------------------------------------------------------------
	 */
#macro(override_default_methods)
		@Override
		public void copyLines( final int lineDir, final int lineLength, final int numLines, final ${src_t} src, final int srcPos, final int srcStep, final ${dest_t} dest, final int destPos, final int destStep )
		{
			if ( lineDir == 1 )
				for ( int i = 0; i < numLines; ++i )
					copyForward( src, srcPos + i * srcStep, dest, destPos + i * destStep, lineLength );
			else if ( lineDir == -1 )
				for ( int i = 0; i < numLines; ++i )
					copyReverse( src, srcPos + i * srcStep, dest, destPos + i * destStep, lineLength );
			else // cstep0 == 0
				for ( int i = 0; i < numLines; ++i )
					copyValue( src, srcPos + i * srcStep, dest, destPos + i * destStep, lineLength );
		}

		@Override
		public void copyNDRangeRecursive(
			final int d,
			final ${src_t} src,
			final int[] srcStrides,
			final int srcPos,
			final ${dest_t} dest,
			final int[] destStrides,
			final int destPos,
			final int[] size )
		{
			final int len = size[ d ];
			if ( d > 0 )
			{
				final int stride_src = srcStrides[ d ];
				final int stride_dst = destStrides[ d ];
				for ( int i = 0; i < len; ++i )
					copyNDRangeRecursive( d - 1,
							src, srcStrides, srcPos + i * stride_src,
							dest, destStrides, destPos + i * stride_dst,
							size );
			}
			else
				copyForward( src, srcPos, dest, destPos, len );
		}
#end
#set( $primitive_types = ["boolean", "byte", "char", "short", "int", "long", "float", "double"] )
#foreach( $t in $primitive_types )
#set( $tuc = $t.substring(0,1).toUpperCase() + $t.substring(1))
#set( $b = $tuc + "Buffer" )



	class MemCopy${tuc} implements MemCopy< ${t}[], ${t}[] >
	{
		@Override
		public void copyForward( final ${t}[] src, final int srcPos, final ${t}[] dest, final int destPos, final int length )
		{
			System.arraycopy( src, srcPos, dest, destPos, length );
		}

		@Override
		public void copyReverse( final ${t}[] src, final int srcPos, final ${t}[] dest, final int destPos, final int length )
		{
			for ( int i = 0; i < length; ++i )
				dest[ destPos + i ] = src[ srcPos - i ];
		}

		@Override
		public void copyValue( final ${t}[] src, final int srcPos, final ${t}[] dest, final int destPos, final int length )
		{
			Arrays.fill( dest, destPos, destPos + length, src[ srcPos ] );
		}

		@Override
		public void copyStrided( final ${t}[] src, final int srcPos, final ${t}[] dest, final int destPos, final int destStride, final int length )
		{
			if ( destStride == 1 )
				copyForward( src, srcPos, dest, destPos, length );
			else
				for ( int i = 0; i < length; ++i )
					dest[ destPos + i * destStride ] = src[ srcPos + i ];
		}
#set( $src_t = $t + "[]" )
#set( $dest_t = $t + "[]" )
#override_default_methods()
	}

#if( !$t.equals("boolean") )
	class MemCopy${tuc}BufferToArray implements MemCopy< ${b}, ${t}[] >
	{
		@Override
		public void copyForward( final ${b} src, final int srcPos, final ${t}[] dest, final int destPos, final int length )
		{
			src.position( srcPos );
			src.get( dest, destPos, length );
		}

		@Override
		public void copyReverse( final ${b} src, final int srcPos, final ${t}[] dest, final int destPos, final int length )
		{
			for ( int i = 0; i < length; ++i )
				dest[ destPos + i ] = src.get( srcPos - i );
		}

		@Override
		public void copyValue( final ${b} src, final int srcPos, final ${t}[] dest, final int destPos, final int length )
		{
			final ${t} val = src.get( srcPos );
			Arrays.fill( dest, destPos, destPos + length, val );
		}

		@Override
		public void copyStrided( final ${b} src, final int srcPos, final ${t}[] dest, final int destPos, final int destStride, final int length )
		{
			if ( destStride == 1 )
				copyForward( src, srcPos, dest, destPos, length );
			else
				for ( int i = 0; i < length; ++i )
					dest[ destPos + i * destStride ] = src.get( srcPos + i );
		}

#set( $src_t = $b )
#set( $dest_t = $t + "[]" )
#override_default_methods()
	}

	class MemCopy${tuc}ArrayToBuffer implements MemCopy< ${t}[], ${b} >
	{
		@Override
		public void copyForward( final ${t}[] src, final int srcPos, final ${b} dest, final int destPos, final int length )
		{
			dest.position( destPos );
			dest.put( src, srcPos, length );
		}

		@Override
		public void copyReverse( final ${t}[] src, final int srcPos, final ${b} dest, final int destPos, final int length )
		{
			for ( int i = 0; i < length; ++i )
				dest.put( destPos + i, src[ srcPos - i ] );
		}

		@Override
		public void copyValue( final ${t}[] src, final int srcPos, final ${b} dest, final int destPos, final int length )
		{
			final ${t} val = src[ srcPos ];
			for ( int i = 0; i < length; ++i )
				dest.put( destPos + i, val );
		}

		@Override
		public void copyStrided( final ${t}[] src, final int srcPos, final ${b} dest, final int destPos, final int destStride, final int length )
		{
			if ( destStride == 1 )
				copyForward( src, srcPos, dest, destPos, length );
			else
				for ( int i = 0; i < length; ++i )
					dest.put( destPos + i * destStride, src[ srcPos + i ] );
		}

#set( $src_t = $t + "[]" )
#set( $dest_t = $b )
#override_default_methods()
	}

	class MemCopy${tuc}BufferToBuffer implements MemCopy< ${b}, ${b} >
	{
		@Override
		public void copyForward( final ${b} src, final int srcPos, final ${b} dest, final int destPos, final int length )
		{
			src.limit( srcPos + length );
			src.position( srcPos );
			dest.position( destPos );
			dest.put( src );
		}

		@Override
		public void copyReverse( final ${b} src, final int srcPos, final ${b} dest, final int destPos, final int length )
		{
			for ( int i = 0; i < length; ++i )
				dest.put( destPos + i, src.get( srcPos - i ) );
		}

		@Override
		public void copyValue( final ${b} src, final int srcPos, final ${b} dest, final int destPos, final int length )
		{
			final ${t} val = src.get( srcPos );
			for ( int i = 0; i < length; ++i )
				dest.put( destPos + i, val );
		}

		@Override
		public void copyStrided( final ${b} src, final int srcPos, final ${b} dest, final int destPos, final int destStride, final int length )
		{
			if ( destStride == 1 )
				copyForward( src, srcPos, dest, destPos, length );
			else
				for ( int i = 0; i < length; ++i )
					dest.put( destPos + i * destStride, src.get( srcPos + i ) );
		}

#set( $src_t = $b )
#set( $dest_t = $b )
#override_default_methods()
	}

#end
#end
}
